{
  "language": "Solidity",
  "sources": {
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/Address.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n    // for accounts without code, i.e. `keccak256('')`\n    bytes32 codehash;\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      codehash := extcodehash(account)\n    }\n    return (codehash != accountHash && codehash != 0x0);\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, 'Address: insufficient balance');\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{value: amount}('');\n    require(success, 'Address: unable to send value, recipient may have reverted');\n  }\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address payable) {\n    return payable(msg.sender);\n  }\n\n  function _msgData() internal view virtual returns (bytes memory) {\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    return msg.data;\n  }\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport './Context.sol';\nimport './IERC20.sol';\nimport './SafeMath.sol';\nimport './Address.sol';\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n   * a default value of 18.\n   *\n   * To select a different value for {decimals}, use {_setupDecimals}.\n   *\n   * All three of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory name, string memory symbol) {\n    _name = name;\n    _symbol = symbol;\n    _decimals = 18;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n   * called.\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account) public view override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(\n    address owner,\n    address spender\n  ) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20};\n   *\n   * Requirements:\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``sender``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance')\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  ) public virtual returns (bool) {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].sub(\n        subtractedValue,\n        'ERC20: decreased allowance below zero'\n      )\n    );\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n    require(sender != address(0), 'ERC20: transfer from the zero address');\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(amount, 'ERC20: transfer amount exceeds balance');\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: mint to the zero address');\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: burn from the zero address');\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(amount, 'ERC20: burn amount exceeds balance');\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n   *\n   * This is internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\n    require(owner != address(0), 'ERC20: approve from the zero address');\n    require(spender != address(0), 'ERC20: approve to the zero address');\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Sets {decimals} to a value other than the default one of 18.\n   *\n   * WARNING: This function should only be called from the constructor. Most\n   * applications that interact with token contracts will not expect\n   * {decimals} to ever change, and may work incorrectly if it does.\n   */\n  function _setupDecimals(uint8 decimals_) internal {\n    _decimals = decimals_;\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be to transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary SafeMath {\n  /// @notice Returns x + y, reverts if sum overflows uint256\n  /// @param x The augend\n  /// @param y The addend\n  /// @return z The sum of x and y\n  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    unchecked {\n      require((z = x + y) >= x);\n    }\n  }\n\n  /// @notice Returns x - y, reverts if underflows\n  /// @param x The minuend\n  /// @param y The subtrahend\n  /// @return z The difference of x and y\n  function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    unchecked {\n      require((z = x - y) <= x);\n    }\n  }\n\n  /// @notice Returns x - y, reverts if underflows\n  /// @param x The minuend\n  /// @param y The subtrahend\n  /// @param message The error msg\n  /// @return z The difference of x and y\n  function sub(uint256 x, uint256 y, string memory message) internal pure returns (uint256 z) {\n    unchecked {\n      require((z = x - y) <= x, message);\n    }\n  }\n\n  /// @notice Returns x * y, reverts if overflows\n  /// @param x The multiplicand\n  /// @param y The multiplier\n  /// @return z The product of x and y\n  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    unchecked {\n      require(x == 0 || (z = x * y) / x == y);\n    }\n  }\n\n  /// @notice Returns x / y, reverts if overflows - no specific check, solidity reverts on division by 0\n  /// @param x The numerator\n  /// @param y The denominator\n  /// @return z The product of x and y\n  function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    return x / y;\n  }\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IERC20WithPermit.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\n\n/**\n * @title IERC20WithPermit\n * @author Aave\n * @notice Interface for the permit function (EIP-2612)\n */\ninterface IERC20WithPermit is IERC20 {\n  /**\n   * @notice Allow passing a signed message to approve spending\n   * @dev implements the permit function as for\n   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n   * @param owner The owner of the funds\n   * @param spender The spender\n   * @param value The amount\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param v Signature param\n   * @param s Signature param\n   * @param r Signature param\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/mocks/tokens/MintableERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {ERC20} from '../../dependencies/openzeppelin/contracts/ERC20.sol';\nimport {IERC20WithPermit} from '../../interfaces/IERC20WithPermit.sol';\n\n/**\n * @title ERC20Mintable\n * @dev ERC20 minting logic\n */\ncontract MintableERC20 is IERC20WithPermit, ERC20 {\n  bytes public constant EIP712_REVISION = bytes('1');\n  bytes32 internal constant EIP712_DOMAIN =\n    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  // Map of address nonces (address => nonce)\n  mapping(address => uint256) internal _nonces;\n\n  bytes32 public DOMAIN_SEPARATOR;\n\n  constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol) {\n    uint256 chainId = block.chainid;\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        EIP712_DOMAIN,\n        keccak256(bytes(name)),\n        keccak256(EIP712_REVISION),\n        chainId,\n        address(this)\n      )\n    );\n    _setupDecimals(decimals);\n  }\n\n  /// @inheritdoc IERC20WithPermit\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    require(owner != address(0), 'INVALID_OWNER');\n    //solium-disable-next-line\n    require(block.timestamp <= deadline, 'INVALID_EXPIRATION');\n    uint256 currentValidNonce = _nonces[owner];\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        '\\x19\\x01',\n        DOMAIN_SEPARATOR,\n        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))\n      )\n    );\n    require(owner == ecrecover(digest, v, r, s), 'INVALID_SIGNATURE');\n    _nonces[owner] = currentValidNonce + 1;\n    _approve(owner, spender, value);\n  }\n\n  /**\n   * @dev Function to mint tokens\n   * @param value The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(uint256 value) public returns (bool) {\n    _mint(_msgSender(), value);\n    return true;\n  }\n\n  /**\n   * @dev Function to mint tokens to address\n   * @param account The account to mint tokens.\n   * @param value The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(address account, uint256 value) public returns (bool) {\n    _mint(account, value);\n    return true;\n  }\n\n  function nonces(address owner) public view virtual returns (uint256) {\n    return _nonces[owner];\n  }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Immutable state\n/// @notice Functions that return immutable state of the router\ninterface IPeripheryImmutableState {\n    /// @return Returns the address of the Uniswap V3 factory\n    function factory() external view returns (address);\n\n    /// @return Returns the address of WETH9\n    function WETH9() external view returns (address);\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/IPeripheryPayments.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Periphery Payments\n/// @notice Functions to ease deposits and withdrawals of ETH\ninterface IPeripheryPayments {\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\n    /// @param recipient The address receiving ETH\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\n\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n    /// that use ether for the input amount\n    function refundETH() external payable;\n\n    /// @notice Transfers the full amount of a token held by this contract to recipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    /// @param token The contract address of the token which will be transferred to `recipient`\n    /// @param amountMinimum The minimum amount of token required for a transfer\n    /// @param recipient The destination address of the token\n    function sweepToken(\n        address token,\n        uint256 amountMinimum,\n        address recipient\n    ) external payable;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/IPoolInitializer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Creates and initializes V3 Pools\n/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that\n/// require the pool to exist.\ninterface IPoolInitializer {\n    /// @notice Creates a new pool if it does not exist, then initializes if not initialized\n    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool\n    /// @param token0 The contract address of token0 of the pool\n    /// @param token1 The contract address of token1 of the pool\n    /// @param fee The fee amount of the v3 pool for the specified token pair\n    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value\n    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary\n    function createAndInitializePoolIfNecessary(\n        address token0,\n        address token1,\n        uint24 fee,\n        uint160 sqrtPriceX96\n    ) external payable returns (address pool);\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH =\n        0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(\n        address factory,\n        PoolKey memory key\n    ) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint160(\n                uint(\n                    keccak256(\n                        abi.encodePacked(\n                            abi.encodePacked(\n                                hex\"ff\",\n                                factory,\n                                keccak256(\n                                    abi.encode(key.token0, key.token1, key.fee)\n                                ),\n                                POOL_INIT_CODE_HASH\n                            )\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/CoreVoting.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\nimport \"./interfaces/IVotingVault.sol\";\nimport \"./libraries/Authorizable.sol\";\nimport \"./libraries/ReentrancyBlock.sol\";\nimport \"./interfaces/ICoreVoting.sol\";\n\ncontract CoreVoting is Authorizable, ReentrancyBlock, ICoreVoting {\n    // if a function selector does not have a set quorum we use this default quorum\n    uint256 public baseQuorum;\n\n    // Assumes avg block time of 13.3 seconds. May be longer or shorter due\n    // to ice ages or short term changes in hash power.\n    uint256 public constant DAY_IN_BLOCKS = 6496;\n\n    // minimum time a proposal must be active for before executing\n    // Default to 3 days, this avoids weekend surprise proposals\n    uint256 public lockDuration = DAY_IN_BLOCKS * 3;\n\n    // The number of blocks after the proposal is unlocked during which\n    // voting can continue. Max vote time = lockDuration + extraVoteTime\n    // Default to ~5 days of blocks, ie 8 days max vote time\n    uint256 public extraVoteTime = DAY_IN_BLOCKS * 5;\n\n    // minimum amount of voting power required to submit a proposal\n    uint256 public minProposalPower;\n\n    // number of proposals created\n    uint256 public proposalCount;\n\n    // mapping of address and selector to quorum\n    mapping(address => mapping(bytes4 => uint256)) private _quorums;\n\n    /// @notice Override of the getter for the 'quorums' mapping which returns the default\n    ///         quorum when the quorum is not set.\n    /// @param target the contract for which the quorum is set\n    /// @param functionSelector the function which is callable\n    /// @return The quorum needed to pass the function at this point in time\n    function quorums(\n        address target,\n        bytes4 functionSelector\n    ) public view returns (uint256) {\n        uint256 storedQuorum = _quorums[target][functionSelector];\n\n        if (storedQuorum == 0) {\n            return baseQuorum;\n        } else {\n            return storedQuorum;\n        }\n    }\n\n    // stores approved voting vaults\n    mapping(address => bool) public override approvedVaults;\n\n    // proposal storage with the proposalID as key\n    mapping(uint256 => Proposal) public proposals;\n\n    // mapping of addresses and proposalIDs to vote struct representing\n    // the voting actions taken for each proposal\n    mapping(address => mapping(uint256 => Vote)) public votes;\n\n    enum Ballot {\n        YES,\n        NO,\n        MAYBE\n    }\n\n    struct Proposal {\n        // hash of this proposal's intended function calls\n        bytes32 proposalHash;\n        // block of the proposal creation\n        uint128 created;\n        // timestamp when the proposal can execute\n        uint128 unlock;\n        // expiration time of a proposal\n        uint128 expiration;\n        // the quorum required for the proposal to execute\n        uint128 quorum;\n        // [yes, no, maybe] voting power\n        uint128[3] votingPower;\n        // Timestamp after which if the call has not been executed it cannot be executed\n        uint128 lastCall;\n    }\n\n    struct Vote {\n        // voting power of the vote\n        uint128 votingPower;\n        // direction of the vote\n        Ballot castBallot;\n    }\n\n    event ProposalCreated(\n        uint256 proposalId,\n        uint256 created,\n        uint256 execution,\n        uint256 expiration\n    );\n\n    event ProposalExecuted(uint256 proposalId);\n\n    event Voted(address indexed voter, uint256 indexed proposalId, Vote vote);\n\n    /// @notice constructor\n    /// @param _timelock Timelock contract.\n    /// @param _baseQuorum Default quorum for all functions with no set quorum.\n    /// @param _minProposalPower Minimum voting power needed to submit a proposal.\n    /// @param _gsc governance steering committee contract.\n    /// @param votingVaults Initial voting vaults to approve.\n    constructor(\n        address _timelock,\n        uint256 _baseQuorum,\n        uint256 _minProposalPower,\n        address _gsc,\n        address[] memory votingVaults\n    ) Authorizable() {\n        baseQuorum = _baseQuorum;\n        minProposalPower = _minProposalPower;\n        for (uint256 i = 0; i < votingVaults.length; i++) {\n            approvedVaults[votingVaults[i]] = true;\n        }\n        setOwner(address(_timelock));\n        _authorize(_gsc);\n    }\n\n    /// @notice Create a new proposal\n    /// @dev all provided votingVaults must be approved vaults `approvedVaults`.\n    /// @param votingVaults voting vaults to draw voting power from.\n    /// @param extraVaultData an encoded list of extra data to provide to vaults\n    /// @param targets list of target addresses the timelock contract will interact with.\n    /// @param calldatas execution calldata for each target.\n    /// @param lastCall timestamp after which this cannot be executed, note should be\n    ///                 more than the voting time period\n    /// @param ballot vote direction (yes, no, maybe)\n    function proposal(\n        address[] calldata votingVaults,\n        bytes[] calldata extraVaultData,\n        address[] calldata targets,\n        bytes[] calldata calldatas,\n        uint256 lastCall,\n        Ballot ballot\n    ) external {\n        require(targets.length == calldatas.length, \"array length mismatch\");\n        require(targets.length != 0, \"empty proposal\");\n\n        // the hash is only used to verify the proposal data, proposals are tracked by ID\n        // so there is no need to hash with proposalCount nonce.\n        bytes32 proposalHash = keccak256(abi.encode(targets, calldatas));\n\n        // get the quorum requirement for this proposal. The quorum requirement is equal to\n        // the greatest quorum item in the proposal\n        uint256 quorum;\n        for (uint256 i = 0; i < targets.length; i++) {\n            // function selector should be the first 4 bytes of the calldata\n            bytes4 selector = _getSelector(calldatas[i]);\n            uint256 unitQuorum = _quorums[targets[i]][selector];\n\n            // don't assume baseQuorum is the highest\n            unitQuorum = unitQuorum == 0 ? baseQuorum : unitQuorum;\n            if (unitQuorum > quorum) {\n                quorum = unitQuorum;\n            }\n        }\n\n        // We check that the expiration is possibly valid\n        require(\n            lastCall > block.number + lockDuration + extraVoteTime,\n            \"expires before voting ends\"\n        );\n\n        proposals[proposalCount] = Proposal(\n            proposalHash,\n            // Note we use blocknumber - 1 here as a flash loan mitigation.\n            uint128(block.number - 1),\n            uint128(block.number + lockDuration),\n            uint128(block.number + lockDuration + extraVoteTime),\n            uint128(quorum),\n            proposals[proposalCount].votingPower,\n            uint128(lastCall)\n        );\n\n        uint256 votingPower = vote(\n            votingVaults,\n            extraVaultData,\n            proposalCount,\n            ballot\n        );\n\n        // the proposal quorum is the lowest of minProposalPower and the proposal quorum\n        // because it is awkward for the proposal to require more voting power than\n        // the execution\n        uint256 minPower = quorum <= minProposalPower\n            ? quorum\n            : minProposalPower;\n        // the GSC (governance steering comity) contract does not have a voting power requirement\n        // to submit a proposal\n        if (!isAuthorized(msg.sender)) {\n            require(votingPower >= minPower, \"insufficient voting power\");\n        }\n\n        emit ProposalCreated(\n            proposalCount,\n            block.number,\n            block.number + lockDuration,\n            block.number + lockDuration + extraVoteTime\n        );\n\n        proposalCount += 1;\n    }\n\n    /// @notice Votes for a new proposal.\n    /// @dev all provided votingVaults must be approved vaults `approvedVaults`.\n    /// Addresses can re-vote, but the previous vote's effect will be negated.\n    /// @param votingVaults voting vaults to draw voting power from.\n    /// @param extraVaultData extra bytes data to give to each vault\n    /// @param proposalId proposal identifier.\n    /// @param ballot vote direction (yes, no, maybe)\n    /// @return the user's voting power\n    function vote(\n        address[] memory votingVaults,\n        bytes[] memory extraVaultData,\n        uint256 proposalId,\n        Ballot ballot\n    ) public returns (uint256) {\n        // No votes after the vote period is over\n        require(proposals[proposalId].created != 0, \"proposal does not exist\");\n        require(block.number <= proposals[proposalId].expiration, \"Expired\");\n\n        uint128 votingPower;\n\n        for (uint256 i = 0; i < votingVaults.length; i++) {\n            // ensure there are no voting vault duplicates\n            for (uint256 j = i + 1; j < votingVaults.length; j++) {\n                require(votingVaults[i] != votingVaults[j], \"duplicate vault\");\n            }\n            require(approvedVaults[votingVaults[i]], \"unverified vault\");\n            votingPower += uint128(\n                IVotingVault(votingVaults[i]).queryVotePower(\n                    msg.sender,\n                    proposals[proposalId].created,\n                    extraVaultData[i]\n                )\n            );\n        }\n\n        // if a user has already voted, undo their previous vote.\n        // NOTE: A new vote can have less voting power\n        if (votes[msg.sender][proposalId].votingPower > 0) {\n            proposals[proposalId].votingPower[\n                uint256(votes[msg.sender][proposalId].castBallot)\n            ] -= votes[msg.sender][proposalId].votingPower;\n        }\n        votes[msg.sender][proposalId] = Vote(votingPower, ballot);\n\n        proposals[proposalId].votingPower[uint256(ballot)] += votingPower;\n\n        // Emit an event to track this info\n        emit Voted(msg.sender, proposalId, votes[msg.sender][proposalId]);\n\n        return votingPower;\n    }\n\n    /// @notice Execute a proposal.\n    /// @param proposalId proposal identifier.\n    /// @param targets list of target addresses the timelock contract will interact with.\n    /// @param calldatas execution calldata for each target.\n    function execute(\n        uint256 proposalId,\n        address[] memory targets,\n        bytes[] memory calldatas\n    ) external nonReentrant {\n        // We have to execute after min voting period\n        require(block.number >= proposals[proposalId].unlock, \"not unlocked\");\n        // If executed the proposal will be deleted and this will be zero\n        require(proposals[proposalId].unlock != 0, \"Previously executed\");\n        // We cannot execute if the proposal has expired\n        require(\n            block.number < proposals[proposalId].lastCall,\n            \"past last call timestamp\"\n        );\n\n        // ensure the data matches the hash\n        require(\n            keccak256(abi.encode(targets, calldatas)) ==\n                proposals[proposalId].proposalHash,\n            \"hash mismatch\"\n        );\n\n        uint128[3] memory results = proposals[proposalId].votingPower;\n        // if there are enough votes to meet quorum and there are more yes votes than no votes\n        // then the proposal is executed\n        bool passesQuorum = results[0] + results[1] + results[2] >=\n            proposals[proposalId].quorum;\n        bool majorityInFavor = results[0] > results[1];\n\n        require(passesQuorum && majorityInFavor, \"Cannot execute\");\n\n        // Execute a package of low level calls\n        // NOTE - All of them must succeed for the package to succeed.\n        for (uint256 i = 0; i < targets.length; i++) {\n            (bool success, ) = targets[i].call(calldatas[i]);\n            require(success, \"Call failed\");\n        }\n        // Notification of proposal execution\n        emit ProposalExecuted(proposalId);\n\n        // delete proposal for some gas savings,\n        // Proposals are only deleted when they are actually executed, failed proposals\n        // are never deleted\n        delete proposals[proposalId];\n    }\n\n    /// @notice gets the current voting power for a proposal\n    /// @param proposalId The proposal's ID.\n    function getProposalVotingPower(\n        uint256 proposalId\n    ) external view returns (uint128[3] memory) {\n        return proposals[proposalId].votingPower;\n    }\n\n    /// @notice Sets a quorum for a specific address and selector.\n    /// @param target Target contract address.\n    /// @param selector Function selector.\n    /// @param quorum Fraction to set quorum to.\n    function setCustomQuorum(\n        address target,\n        bytes4 selector,\n        uint256 quorum\n    ) external onlyOwner {\n        _quorums[target][selector] = quorum;\n    }\n\n    /// @notice Updates the status of a voting vault.\n    /// @param vault Address of the voting vault.\n    /// @param isValid True to be valid, false otherwise.\n    function changeVaultStatus(address vault, bool isValid) external onlyOwner {\n        approvedVaults[vault] = isValid;\n    }\n\n    /// @notice Updates the default quorum.\n    /// @param quorum New base quorum.\n    function setDefaultQuorum(uint256 quorum) external onlyOwner {\n        baseQuorum = quorum;\n    }\n\n    /// @notice Updates the minimum voting power needed to submit a proposal.\n    /// @param _minProposalPower Minimum voting power needed to submit a proposal.\n    function setMinProposalPower(uint256 _minProposalPower) external onlyOwner {\n        minProposalPower = _minProposalPower;\n    }\n\n    /// @notice Updates the lock duration of a proposal.\n    /// @param _lockDuration New lock duration.\n    function setLockDuration(uint256 _lockDuration) external onlyOwner {\n        lockDuration = _lockDuration;\n    }\n\n    /// @notice Updates the extra voting period\n    /// @param _extraVoteTime New extra voting time\n    function changeExtraVotingTime(uint256 _extraVoteTime) external onlyOwner {\n        extraVoteTime = _extraVoteTime;\n    }\n\n    /// @notice Internal helper function to get the function selector of a calldata string.\n    function _getSelector(\n        bytes memory _calldata\n    ) internal pure returns (bytes4 out) {\n        assembly {\n            out := and(\n                mload(add(_calldata, 32)),\n                0xFFFFFFFFF0000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n}\n"
    },
    "contracts/features/Timelock.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\nimport \"../libraries/Authorizable.sol\";\nimport \"../libraries/ReentrancyBlock.sol\";\n\n// Allows a call to be executed after a waiting period, also allows a call to\n// be canceled within a waiting period.\n\ncontract Timelock is Authorizable, ReentrancyBlock {\n    // Amount of time for the waiting period\n    uint256 public waitTime;\n\n    // Mapping of call hashes to block timestamps\n    mapping(bytes32 => uint256) public callTimestamps;\n    // Mapping from a call hash to its status of once allowed time increase\n    mapping(bytes32 => bool) public timeIncreases;\n\n    /// @notice Constructs this contract and sets state variables\n    /// @param _waitTime amount of time for the waiting period\n    /// @param _governance governance\n    /// @param _gsc governance steering committee contract.\n    constructor(\n        uint256 _waitTime,\n        address _governance,\n        address _gsc\n    ) Authorizable() {\n        _authorize(_gsc);\n        waitTime = _waitTime;\n        setOwner(_governance);\n    }\n\n    /// @notice Stores at the callHash the current block timestamp\n    /// @param callHash The hash to map the timestamp to\n    function registerCall(bytes32 callHash) external onlyOwner {\n        // We only want to register a call which is not already active\n        require(callTimestamps[callHash] == 0, \"already registered\");\n        // Set the timestamp for this call package to be the current time\n        callTimestamps[callHash] = block.timestamp;\n    }\n\n    /// @notice Removes stored callHash data\n    /// @param callHash Which entry of the mapping to remove\n    function stopCall(bytes32 callHash) external onlyOwner {\n        // We only want this to actually execute when a real thing is deleted to\n        // prevent re-ordering attacks\n        require(callTimestamps[callHash] != 0, \"No call to be removed\");\n        // Do the actual deletion\n        delete callTimestamps[callHash];\n        delete timeIncreases[callHash];\n    }\n\n    /// @notice Execute the call if past the waiting period\n    /// @param targets List of target addresses the timelock contract will interact with\n    /// @param calldatas Execution calldata for each target\n    function execute(\n        address[] memory targets,\n        bytes[] calldata calldatas\n    ) public nonReentrant {\n        // hash provided data to access the mapping\n        bytes32 callHash = keccak256(abi.encode(targets, calldatas));\n        // call defaults to zero and cannot be executed before it is registered\n        require(callTimestamps[callHash] != 0, \"call has not been initialized\");\n        // call cannot be executed before the waiting period has passed\n        require(\n            callTimestamps[callHash] + waitTime < block.timestamp,\n            \"not enough time has passed\"\n        );\n        // Gives a revert string to a revert that would occur anyway when the array is accessed\n        require(targets.length == calldatas.length, \"invalid formatting\");\n        // execute a package of low level calls\n        for (uint256 i = 0; i < targets.length; i++) {\n            (bool success, ) = targets[i].call(calldatas[i]);\n            // revert if a single call fails\n            require(success == true, \"call reverted\");\n        }\n        // restore state after successful execution\n        delete callTimestamps[callHash];\n        delete timeIncreases[callHash];\n    }\n\n    /// @notice Allow a call from this contract to reset the wait time storage variable\n    /// @param _waitTime New wait time to set to\n    function setWaitTime(uint256 _waitTime) public {\n        require(msg.sender == address(this), \"contract must be self\");\n        waitTime = _waitTime;\n    }\n\n    /// @notice Allow an increase in wait time for a given call\n    /// can only be executed once for each call\n    /// @param timeValue Amount of time to increase by\n    /// @param callHash The mapping entry to increase time\n    function increaseTime(\n        uint256 timeValue,\n        bytes32 callHash\n    ) external onlyAuthorized {\n        require(\n            timeIncreases[callHash] == false,\n            \"value can only be changed once\"\n        );\n        require(\n            callTimestamps[callHash] != 0,\n            \"must have been previously registered\"\n        );\n        // Increases the time till the call can be executed\n        callTimestamps[callHash] += timeValue;\n        // set mapping to indicate call has been changed\n        timeIncreases[callHash] = true;\n    }\n}\n"
    },
    "contracts/features/Treasury.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\nimport \"../libraries/Authorizable.sol\";\nimport \"../interfaces/IERC20.sol\";\n\n// This contract is designed to hold the erc20 and eth reserves of the dao\n// and will likely control a large amount of funds. It is designed to be\n// flexible, secure and simple\ncontract Treasury is Authorizable {\n    // A constant which represents ether\n    address internal constant _ETH_CONSTANT =\n        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    /// @notice constructor.\n    /// @param __governance Governance contract address.\n    constructor(address __governance) {\n        setOwner(__governance);\n    }\n\n    ///@notice Sends funds from the treasury to an address.\n    ///@param _token Either (1) An ERC20 token address\n    /// or (2) the _ETH_CONSTANT to use transfer ETH.\n    ///@param _amount The amount of ETH or ERC20 to send.\n    ///@param _recipient The recipient of this value.\n    function sendFunds(\n        address _token,\n        uint256 _amount,\n        address _recipient\n    ) external onlyOwner {\n        if (_token == _ETH_CONSTANT) {\n            payable(_recipient).transfer(_amount);\n        } else {\n            // onlyGovernance should protect from reentrancy\n            IERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    ///@notice Sets an ERC20 allowance from this contract to a _spender.\n    ///@param _token The ERC20 token address.\n    ///@param _spender The recipient of the allowance.\n    ///@param _amount The amount of the allowance.\n    function approve(\n        address _token,\n        address _spender,\n        uint256 _amount\n    ) external onlyOwner {\n        IERC20(_token).approve(_spender, _amount);\n    }\n\n    ///@notice Performs a generic call from this contract.\n    ///@param _target The target address where the call will be performed.\n    ///@param _callData The execution calldata to pass.\n    function genericCall(\n        address _target,\n        bytes calldata _callData\n    ) external onlyOwner {\n        // We do a low level call and insist it succeeds\n        (bool status, ) = _target.call(_callData);\n        require(status, \"Call failed\");\n    }\n\n    // Receive is fine because we don't want to execute code\n    receive() external payable {}\n}\n"
    },
    "contracts/interfaces/ICoreVoting.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\ninterface ICoreVoting {\n    /// @notice A method auto generated from a public storage mapping, looks\n    ///         up which vault addresses are approved by core voting\n    /// @param vault the address to check if it is an approved vault\n    /// @return true if approved false if not approved\n    function approvedVaults(address vault) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\ninterface IERC20 {\n    function symbol() external view returns (string memory);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    // Note this is non standard but nearly all ERC20 have exposed decimal functions\n    function decimals() external view returns (uint8);\n\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/interfaces/IERC20Permit.sol": {
      "content": "// Forked from openzepplin\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.3;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit is IERC20 {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IERC721Enumerable.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n\n// pragma solidity ^0.8.3;\n\n// import \"../vaults/IERC721.sol\";\n\n// /**\n//  * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n//  * @dev See https://eips.ethereum.org/EIPS/eip-721\n//  */\n// interface IERC721Enumerable is IERC721 {\n//     /**\n//      * @dev Returns the total amount of tokens stored by the contract.\n//      */\n//     function totalSupply() external view returns (uint256);\n\n//     /**\n//      * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n//      * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n//      */\n//     function tokenOfOwnerByIndex(\n//         address owner,\n//         uint256 index\n//     ) external view returns (uint256 tokenId);\n\n//     /**\n//      * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n//      * Use along with {totalSupply} to enumerate all tokens.\n//      */\n//     function tokenByIndex(uint256 index) external view returns (uint256);\n// }\n"
    },
    "contracts/interfaces/IERC721Metadata.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n\n// pragma solidity ^0.8.3;\n\n// import \"../vaults/IERC721.sol\";\n\n// /**\n//  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n//  * @dev See https://eips.ethereum.org/EIPS/eip-721\n//  */\n// interface IERC721Metadata is IERC721 {\n//     /**\n//      * @dev Returns the token collection name.\n//      */\n//     function name() external view returns (string memory);\n\n//     /**\n//      * @dev Returns the token collection symbol.\n//      */\n//     function symbol() external view returns (string memory);\n\n//     /**\n//      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n//      */\n//     function tokenURI(uint256 tokenId) external view returns (string memory);\n// }\n"
    },
    "contracts/interfaces/IERC721Permit.sol": {
      "content": "// // SPDX-License-Identifier: GPL-2.0-or-later\n// pragma solidity >=0.7.5;\n\n// import \"../vaults/IERC721.sol\";\n\n// /// @title ERC721 with permit\n// /// @notice Extension to ERC721 that includes a permit function for signature based approvals\n// interface IERC721Permit is IERC721 {\n//     /// @notice The permit typehash used in the permit signature\n//     /// @return The typehash for the permit\n//     function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n//     /// @notice The domain separator used in the permit signature\n//     /// @return The domain seperator used in encoding of permit signature\n//     function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n//     /// @notice Approve of a specific token ID for spending by spender via signature\n//     /// @param spender The account that is being approved\n//     /// @param tokenId The ID of the token that is being approved for spending\n//     /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\n//     /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n//     /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n//     /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n//     function permit(\n//         address spender,\n//         uint256 tokenId,\n//         uint256 deadline,\n//         uint8 v,\n//         bytes32 r,\n//         bytes32 s\n//     ) external payable;\n// }\n"
    },
    "contracts/interfaces/ILockingVault.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\nimport \"./IERC20.sol\";\n\ninterface ILockingVault {\n    /// @notice Deposits and delegates voting power to an address provided with the call\n    /// @param fundedAccount The address to credit this deposit to\n    /// @param amount The amount of token which is deposited\n    /// @param firstDelegation First delegation address\n    function deposit(\n        address fundedAccount,\n        uint256 amount,\n        address firstDelegation\n    ) external;\n\n    /// @notice Removes tokens from this contract and the voting power they represent\n    /// @param amount The amount of token to withdraw\n    function withdraw(uint256 amount) external;\n\n    /// @notice The token for this locking vault\n    function token() external returns (IERC20);\n\n    /// @notice Changes a user's voting power\n    /// @param newDelegate The new address which gets voting power\n    function changeDelegation(address newDelegate) external;\n}\n"
    },
    "contracts/interfaces/INonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n//import \"./IERC721Enumerable.sol\";\n//import \"./IERC721Metadata.sol\";\n\nimport \"@uniswap/v3-periphery/contracts/interfaces/IPoolInitializer.sol\";\n//import \"./IERC721Permit.sol\"\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IPeripheryPayments.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol\";\nimport \"@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol\";\n\n/// @title Non-fungible token for positions\n/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\n/// and authorized.\ninterface INonfungiblePositionManager is\n    IPoolInitializer,\n    IPeripheryPayments,\n    IPeripheryImmutableState\n    // IERC20Metadata\n    //IERC721Enumerable,\n    // IERC721Permit\n{\n    /// @notice Emitted when liquidity is increased for a position NFT\n    /// @dev Also emitted when a token is minted\n    /// @param tokenId The ID of the token for which liquidity was increased\n    /// @param liquidity The amount by which liquidity for the NFT position was increased\n    /// @param amount0 The amount of token0 that was paid for the increase in liquidity\n    /// @param amount1 The amount of token1 that was paid for the increase in liquidity\n    event IncreaseLiquidity(\n        uint256 indexed tokenId,\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n    /// @notice Emitted when liquidity is decreased for a position NFT\n    /// @param tokenId The ID of the token for which liquidity was decreased\n    /// @param liquidity The amount by which liquidity for the NFT position was decreased\n    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity\n    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity\n    event DecreaseLiquidity(\n        uint256 indexed tokenId,\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n    /// @notice Emitted when tokens are collected for a position NFT\n    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior\n    /// @param tokenId The ID of the token for which underlying tokens were collected\n    /// @param recipient The address of the account that received the collected tokens\n    /// @param amount0 The amount of token0 owed to the position that was collected\n    /// @param amount1 The amount of token1 owed to the position that was collected\n    event Collect(\n        uint256 indexed tokenId,\n        address recipient,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Returns the position information associated with a given token ID.\n    /// @dev Throws if the token ID is not valid.\n    /// @param tokenId The ID of the token that represents the position\n    /// @return nonce The nonce for permits\n    /// @return operator The address that is approved for spending\n    /// @return token0 The address of the token0 for a specific pool\n    /// @return token1 The address of the token1 for a specific pool\n    /// @return fee The fee associated with the pool\n    /// @return tickLower The lower end of the tick range for the position\n    /// @return tickUpper The higher end of the tick range for the position\n    /// @return liquidity The liquidity of the position\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n    function positions(\n        uint256 tokenId\n    )\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n    /// @return tokenId The ID of the token that represents the minted position\n    /// @return liquidity The amount of liquidity for this position\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function mint(\n        MintParams calldata params\n    )\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\n    /// amount0Desired The desired amount of token0 to be spent,\n    /// amount1Desired The desired amount of token1 to be spent,\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return liquidity The new liquidity amount as a result of the increase\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\n    function increaseLiquidity(\n        IncreaseLiquidityParams calldata params\n    )\n        external\n        payable\n        returns (uint128 liquidity, uint256 amount0, uint256 amount1);\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n    /// amount The amount by which liquidity will be decreased,\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n    function decreaseLiquidity(\n        DecreaseLiquidityParams calldata params\n    ) external payable returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n    /// recipient The account that should receive the tokens,\n    /// amount0Max The maximum amount of token0 to collect,\n    /// amount1Max The maximum amount of token1 to collect\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        CollectParams calldata params\n    ) external payable returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n    /// must be collected first.\n    /// @param tokenId The ID of the token that is being burned\n    function burn(uint256 tokenId) external payable;\n}\n"
    },
    "contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(\n        ExactInputSingleParams calldata params\n    ) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(\n        ExactInputParams calldata params\n    ) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(\n        ExactOutputSingleParams calldata params\n    ) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(\n        ExactOutputParams calldata params\n    ) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/IVotingVault.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\ninterface IVotingVault {\n    /// @notice Attempts to load the voting power of a user\n    /// @param user The address we want to load the voting power of\n    /// @param blockNumber the block number we want the user's voting power at\n    /// @param extraData Abi encoded optional extra data used by some vaults, such as merkle proofs\n    /// @return the number of votes\n    function queryVotePower(\n        address user,\n        uint256 blockNumber,\n        bytes calldata extraData\n    ) external returns (uint256);\n}\n"
    },
    "contracts/libraries/Authorizable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.7.0;\n\ncontract Authorizable {\n    // This contract allows a flexible authorization scheme\n\n    // The owner who can change authorization status\n    address public owner;\n    // A mapping from an address to its authorization status\n    mapping(address => bool) public authorized;\n\n    /// @dev We set the deployer to the owner\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// @dev This modifier checks if the msg.sender is the owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Sender not owner\");\n        _;\n    }\n\n    /// @dev This modifier checks if an address is authorized\n    modifier onlyAuthorized() {\n        require(isAuthorized(msg.sender), \"Sender not Authorized\");\n        _;\n    }\n\n    /// @dev Returns true if an address is authorized\n    /// @param who the address to check\n    /// @return true if authorized false if not\n    function isAuthorized(address who) public view returns (bool) {\n        return authorized[who];\n    }\n\n    /// @dev Privileged function authorize an address\n    /// @param who the address to authorize\n    function authorize(address who) external onlyOwner {\n        _authorize(who);\n    }\n\n    /// @dev Privileged function to de authorize an address\n    /// @param who The address to remove authorization from\n    function deauthorize(address who) external onlyOwner {\n        authorized[who] = false;\n    }\n\n    /// @dev Function to change owner\n    /// @param who The new owner address\n    function setOwner(address who) public onlyOwner {\n        owner = who;\n    }\n\n    /// @dev Inheritable function which authorizes someone\n    /// @param who the address to authorize\n    function _authorize(address who) internal {\n        authorized[who] = true;\n    }\n}\n"
    },
    "contracts/libraries/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// Copied from https://github.com/delvtech/elf-contracts/blob/a6cb960896301b7562ced70a8b221f3cc964ea0a/contracts/libraries/ERC20Permit.sol\n\npragma solidity ^0.8.3;\n\nimport \"../interfaces/IERC20Permit.sol\";\n\n// This default erc20 library is designed for max efficiency and security.\n// WARNING: By default it does not include totalSupply which breaks the ERC20 standard\n//          to use a fully standard compliant ERC20 use 'ERC20PermitWithSupply\"\nabstract contract ERC20Permit is IERC20Permit {\n    // --- ERC20 Data ---\n    // The name of the erc20 token\n    string public name;\n    // The symbol of the erc20 token\n    string public override symbol;\n    // The decimals of the erc20 token, should default to 18 for new tokens\n    uint8 public override decimals;\n\n    // A mapping which tracks user token balances\n    mapping(address => uint256) public override balanceOf;\n    // A mapping which tracks which addresses a user allows to move their tokens\n    mapping(address => mapping(address => uint256)) public override allowance;\n    // A mapping which tracks the permit signature nonces for users\n    mapping(address => uint256) public override nonces;\n\n    // --- EIP712 niceties ---\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public override DOMAIN_SEPARATOR;\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice Initializes the erc20 contract\n    /// @param name_ the value 'name' will be set to\n    /// @param symbol_ the value 'symbol' will be set to\n    /// @dev decimals default to 18 and must be reset by an inheriting contract for\n    ///      non standard decimal values\n    constructor(string memory name_, string memory symbol_) {\n        // Set the state variables\n        name = name_;\n        symbol = symbol_;\n        decimals = 18;\n\n        // By setting these addresses to 0 attempting to execute a transfer to\n        // either of them will revert. This is a gas efficient way to prevent\n        // a common user mistake where they transfer to the token address.\n        // These values are not considered 'real' tokens and so are not included\n        // in 'total supply' which only contains minted tokens.\n        balanceOf[address(0)] = type(uint256).max;\n        balanceOf[address(this)] = type(uint256).max;\n\n        // Optional extra state manipulation\n        _extraConstruction();\n\n        // Computes the EIP 712 domain separator which prevents user signed messages for\n        // this contract to be replayed in other contracts.\n        // https://eips.ethereum.org/EIPS/eip-712\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    /// @notice An optional override function to execute and change state before immutable assignment\n    function _extraConstruction() internal virtual {}\n\n    // --- Token ---\n    /// @notice Allows a token owner to send tokens to another address\n    /// @param recipient The address which will be credited with the tokens\n    /// @param amount The amount user token to send\n    /// @return returns true on success, reverts on failure so cannot return false.\n    /// @dev transfers to this contract address or 0 will fail\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        // We forward this call to 'transferFrom'\n        return transferFrom(msg.sender, recipient, amount);\n    }\n\n    /// @notice Transfers an amount of erc20 from a spender to a receipt\n    /// @param spender The source of the ERC20 tokens\n    /// @param recipient The destination of the ERC20 tokens\n    /// @param amount the number of tokens to send\n    /// @return returns true on success and reverts on failure\n    /// @dev will fail transfers which send funds to this contract or 0\n    function transferFrom(\n        address spender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        // Load balance and allowance\n        uint256 balance = balanceOf[spender];\n        require(balance >= amount, \"ERC20: insufficient-balance\");\n        // We potentially have to change allowances\n        if (spender != msg.sender) {\n            // Loading the allowance in the if block prevents vanilla transfers\n            // from paying for the sload.\n            uint256 allowed = allowance[spender][msg.sender];\n            // If the allowance is max we do not reduce it\n            // Note - This means that max allowances will be more gas efficient\n            // by not requiring a sstore on 'transferFrom'\n            if (allowed != type(uint256).max) {\n                require(allowed >= amount, \"ERC20: insufficient-allowance\");\n                allowance[spender][msg.sender] = allowed - amount;\n            }\n        }\n        // Update the balances\n        balanceOf[spender] = balance - amount;\n        // Note - In the constructor we initialize the 'balanceOf' of address 0 and\n        //        the token address to uint256.max and so in 8.0 transfers to those\n        //        addresses revert on this step.\n        balanceOf[recipient] = balanceOf[recipient] + amount;\n        // Emit the needed event\n        emit Transfer(spender, recipient, amount);\n        // Return that this call succeeded\n        return true;\n    }\n\n    /// @notice This internal minting function allows inheriting contracts\n    ///         to mint tokens in the way they wish.\n    /// @param account the address which will receive the token.\n    /// @param amount the amount of token which they will receive\n    /// @dev This function is virtual so that it can be overridden, if you\n    ///      are reviewing this contract for security you should ensure to\n    ///      check for overrides\n    function _mint(address account, uint256 amount) internal virtual {\n        // Add tokens to the account\n        balanceOf[account] = balanceOf[account] + amount;\n        // Emit an event to track the minting\n        emit Transfer(address(0), account, amount);\n    }\n\n    /// @notice This internal burning function allows inheriting contracts to\n    ///         burn tokens in the way they see fit.\n    /// @param account the account to remove tokens from\n    /// @param amount  the amount of tokens to remove\n    /// @dev This function is virtual so that it can be overridden, if you\n    ///      are reviewing this contract for security you should ensure to\n    ///      check for overrides\n    function _burn(address account, uint256 amount) internal virtual {\n        // Reduce the balance of the account\n        balanceOf[account] = balanceOf[account] - amount;\n        // Emit an event tracking transfers\n        emit Transfer(account, address(0), amount);\n    }\n\n    /// @notice This function allows a user to approve an account which can transfer\n    ///         tokens on their behalf.\n    /// @param account The account which will be approve to transfer tokens\n    /// @param amount The approval amount, if set to uint256.max the allowance does not go down on transfers.\n    /// @return returns true for compatibility with the ERC20 standard\n    function approve(\n        address account,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        // Set the senders allowance for account to amount\n        allowance[msg.sender][account] = amount;\n        // Emit an event to track approvals\n        emit Approval(msg.sender, account, amount);\n        return true;\n    }\n\n    /// @notice This function allows a caller who is not the owner of an account to execute the functionality of 'approve' with the owners signature.\n    /// @param owner the owner of the account which is having the new approval set\n    /// @param spender the address which will be allowed to spend owner's tokens\n    /// @param value the new allowance value\n    /// @param deadline the timestamp which the signature must be submitted by to be valid\n    /// @param v Extra ECDSA data which allows public key recovery from signature assumed to be 27 or 28\n    /// @param r The r component of the ECDSA signature\n    /// @param s The s component of the ECDSA signature\n    /// @dev The signature for this function follows EIP 712 standard and should be generated with the\n    ///      eth_signTypedData JSON RPC call instead of the eth_sign JSON RPC call. If using out of date\n    ///      parity signing libraries the v component may need to be adjusted. Also it is very rare but possible\n    ///      for v to be other values, those values are not supported.\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        // The EIP 712 digest for this function\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner],\n                        deadline\n                    )\n                )\n            )\n        );\n        // Require that the owner is not zero\n        require(owner != address(0), \"ERC20: invalid-address-0\");\n        // Require that we have a valid signature from the owner\n        require(owner == ecrecover(digest, v, r, s), \"ERC20: invalid-permit\");\n        // Require that the signature is not expired\n        require(\n            deadline == 0 || block.timestamp <= deadline,\n            \"ERC20: permit-expired\"\n        );\n        // Format the signature to the default format\n        require(\n            uint256(s) <=\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"ERC20: invalid signature 's' value\"\n        );\n        // Increment the signature nonce to prevent replay\n        nonces[owner]++;\n        // Set the allowance to the new value\n        allowance[owner][spender] = value;\n        // Emit an approval event to be able to track this happening\n        emit Approval(owner, spender, value);\n    }\n\n    /// @notice Internal function which allows inheriting contract to set custom decimals\n    /// @param decimals_ the new decimal value\n    function _setupDecimals(uint8 decimals_) internal {\n        // Set the decimals\n        decimals = decimals_;\n    }\n}\n"
    },
    "contracts/libraries/ERC20PermitWithMint.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// Largely based on https://github.com/delvtech/elf-contracts/blob/a6cb960896301b7562ced70a8b221f3cc964ea0a/contracts/libraries/ERC20PermitWithSupply.sol\n\npragma solidity ^0.8.3;\n\nimport \"./ERC20Permit.sol\";\nimport \"./Authorizable.sol\";\n\n// This contract adds total supply and minting to the generic erc20\nabstract contract ERC20PermitWithMint is ERC20Permit, Authorizable {\n    /// @notice Initializes the erc20 contract\n    /// @param name_ the value 'name' will be set to\n    /// @param symbol_ the value 'symbol' will be set to\n    /// @param owner_ address which has the power to mint\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address owner_\n    ) ERC20Permit(name_, symbol_) {\n        setOwner(owner_);\n    }\n\n    // The stored totalSupply, it equals all tokens minted - all tokens burned\n    uint256 public totalSupply;\n\n    /// @notice Allows the governance to mint\n    /// @param account the account to addd tokens to\n    /// @param amount the amount of tokens to add\n    function mint(address account, uint256 amount) external onlyOwner {\n        _mint(account, amount);\n    }\n\n    /// @notice This function overrides the ERC20Permit Library's _mint and causes it\n    ///          to track total supply.\n    /// @param account the account to addd tokens to\n    /// @param amount the amount of tokens to add\n    function _mint(address account, uint256 amount) internal override {\n        // Increase account balance\n        balanceOf[account] = balanceOf[account] + amount;\n        // Increase total supply\n        totalSupply += amount;\n        // Emit a transfer from zero to emulate a mint\n        emit Transfer(address(0), account, amount);\n    }\n\n    /// @notice Allows the governance to burn\n    /// @param account the account to burn from\n    /// @param amount the amount of token to burn\n    function burn(address account, uint256 amount) external onlyOwner {\n        _burn(account, amount);\n    }\n\n    /// @notice This function overrides the ERC20Permit Library's _burn to decrement total supply\n    /// @param account the account to burn from\n    /// @param amount the amount of token to burn\n    function _burn(address account, uint256 amount) internal override {\n        // Decrease user balance\n        uint256 currentBalance = balanceOf[account];\n        // This logic prevents a reversion if the _burn is frontrun\n        if (currentBalance < amount) {\n            balanceOf[account] = 0;\n        } else {\n            balanceOf[account] = currentBalance - amount;\n        }\n        // Decrease total supply\n        totalSupply -= amount;\n        // Emit an event tracking the burn\n        emit Transfer(account, address(0), amount);\n    }\n}\n"
    },
    "contracts/libraries/History.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\nimport \"./Storage.sol\";\n\n// This library is an assembly optimized storage library which is designed\n// to track timestamp history in a struct which uses hash derived pointers.\n// WARNING - Developers using it should not access the underlying storage\n// directly since we break some assumptions of high level solidity. Please\n// note this library also increases the risk profile of memory manipulation\n// please be cautious in your usage of uninitialized memory structs and other\n// anti patterns.\nlibrary History {\n    // The storage layout of the historical array looks like this\n    // [(128 bit min index)(128 bit length)] [0][0] ... [(64 bit block num)(192 bit data)] .... [(64 bit block num)(192 bit data)]\n    // We give the option to the invoker of the search function the ability to clear\n    // stale storage. To find data we binary search for the block number we need\n    // This library expects the blocknumber indexed data to be pushed in ascending block number\n    // order and if data is pushed with the same blocknumber it only retains the most recent.\n    // This ensures each blocknumber is unique and contains the most recent data at the end\n    // of whatever block it indexes [as long as that block is not the current one].\n\n    // A struct which wraps a memory pointer to a string and the pointer to storage\n    // derived from that name string by the storage library\n    // WARNING - For security purposes never directly construct this object always use load\n    struct HistoricalBalances {\n        string name;\n        // Note - We use bytes32 to reduce how easy this is to manipulate in high level sol\n        bytes32 cachedPointer;\n    }\n\n    /// @notice The method by which inheriting contracts init the HistoricalBalances struct\n    /// @param name The name of the variable. Note - these are globals, any invocations of this\n    ///             with the same name work on the same storage.\n    /// @return The memory pointer to the wrapper of the storage pointer\n    function load(\n        string memory name\n    ) internal pure returns (HistoricalBalances memory) {\n        mapping(address => uint256[]) storage storageData = Storage\n            .mappingAddressToUnit256ArrayPtr(name);\n        bytes32 pointer;\n        assembly {\n            pointer := storageData.slot\n        }\n        return HistoricalBalances(name, pointer);\n    }\n\n    /// @notice An unsafe method of attaching the cached ptr in a historical balance memory objects\n    /// @param pointer cached pointer to storage\n    /// @return storageData A storage array mapping pointer\n    /// @dev PLEASE DO NOT USE THIS METHOD WITHOUT SERIOUS REVIEW. IF AN EXTERNAL ACTOR CAN CALL THIS WITH\n    //       ARBITRARY DATA THEY MAY BE ABLE TO OVERWRITE ANY STORAGE IN THE CONTRACT.\n    function _getMapping(\n        bytes32 pointer\n    ) private pure returns (mapping(address => uint256[]) storage storageData) {\n        assembly {\n            storageData.slot := pointer\n        }\n    }\n\n    /// @notice This function adds a block stamp indexed piece of data to a historical data array\n    ///         To prevent duplicate entries if the top of the array has the same blocknumber\n    ///         the value is updated instead\n    /// @param wrapper The wrapper which hold the reference to the historical data storage pointer\n    /// @param who The address which indexes the array we need to push to\n    /// @param data The data to append, should be at most 192 bits and will revert if not\n    function push(\n        HistoricalBalances memory wrapper,\n        address who,\n        uint256 data\n    ) internal {\n        // Check preconditions\n        // OoB = Out of Bounds, short for contract bytecode size reduction\n        require(data <= type(uint192).max, \"OoB\");\n        // Get the storage this is referencing\n        mapping(address => uint256[]) storage storageMapping = _getMapping(\n            wrapper.cachedPointer\n        );\n        // Get the array we need to push to\n        uint256[] storage storageData = storageMapping[who];\n        // We load the block number and then shift it to be in the top 64 bits\n        uint256 blockNumber = block.number << 192;\n        // We combine it with the data, because of our require this will have a clean\n        // top 64 bits\n        uint256 packedData = blockNumber | data;\n        // Load the array length\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\n        // On the first push we don't try to load\n        uint256 loadedBlockNumber = 0;\n        if (length != 0) {\n            (loadedBlockNumber, ) = _loadAndUnpack(storageData, length - 1);\n        }\n        // The index we push to, note - we use this pattern to not branch the assembly\n        uint256 index = length;\n        // If the caller is changing data in the same block we change the entry for this block\n        // instead of adding a new one. This ensures each block numb is unique in the array.\n        if (loadedBlockNumber == block.number) {\n            index = length - 1;\n        }\n        // We use assembly to write our data to the index\n        assembly {\n            // Stores packed data in the equivalent of storageData[length]\n            sstore(\n                add(\n                    // The start of the data slots\n                    add(storageData.slot, 1),\n                    // index where we store\n                    index\n                ),\n                packedData\n            )\n        }\n        // Reset the boundaries if they changed\n        if (loadedBlockNumber != block.number) {\n            _setBounds(storageData, minIndex, length + 1);\n        }\n    }\n\n    /// @notice Loads the most recent timestamp of delegation power\n    /// @param wrapper The memory struct which we want to search for historical data\n    /// @param who The user who's balance we want to load\n    /// @return the top slot of the array\n    function loadTop(\n        HistoricalBalances memory wrapper,\n        address who\n    ) internal view returns (uint256) {\n        // Load the storage pointer\n        uint256[] storage userData = _getMapping(wrapper.cachedPointer)[who];\n        // Load the length\n        (, uint256 length) = _loadBounds(userData);\n        // If it's zero no data has ever been pushed so we return zero\n        if (length == 0) {\n            return 0;\n        }\n        // Load the current top\n        (, uint256 storedData) = _loadAndUnpack(userData, length - 1);\n        // and return it\n        return (storedData);\n    }\n\n    /// @notice Finds the data stored with the highest block number which is less than or equal to a provided\n    ///         blocknumber.\n    /// @param wrapper The memory struct which we want to search for historical data\n    /// @param who The address which indexes the array to be searched\n    /// @param blocknumber The blocknumber we want to load the historical data of\n    /// @return The loaded unpacked data at this point in time.\n    function find(\n        HistoricalBalances memory wrapper,\n        address who,\n        uint256 blocknumber\n    ) internal view returns (uint256) {\n        // Get the storage this is referencing\n        mapping(address => uint256[]) storage storageMapping = _getMapping(\n            wrapper.cachedPointer\n        );\n        // Get the array we need to push to\n        uint256[] storage storageData = storageMapping[who];\n        // Pre load the bounds\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\n        // Search for the blocknumber\n        (, uint256 loadedData) = _find(\n            storageData,\n            blocknumber,\n            0,\n            minIndex,\n            length\n        );\n        // In this function we don't have to change the stored length data\n        return (loadedData);\n    }\n\n    /// @notice Finds the data stored with the highest blocknumber which is less than or equal to a provided block number\n    ///         Opportunistically clears any data older than staleBlock which is possible to clear.\n    /// @param wrapper The memory struct which points to the storage we want to search\n    /// @param who The address which indexes the historical data we want to search\n    /// @param blocknumber The blocknumber we want to load the historical state of\n    /// @param staleBlock A block number which we can [but are not obligated to] delete history older than\n    /// @return The found data\n    function findAndClear(\n        HistoricalBalances memory wrapper,\n        address who,\n        uint256 blocknumber,\n        uint256 staleBlock\n    ) internal returns (uint256) {\n        // Get the storage this is referencing\n        mapping(address => uint256[]) storage storageMapping = _getMapping(\n            wrapper.cachedPointer\n        );\n        // Get the array we need to push to\n        uint256[] storage storageData = storageMapping[who];\n        // Pre load the bounds\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\n        // Search for the blocknumber\n        (uint256 staleIndex, uint256 loadedData) = _find(\n            storageData,\n            blocknumber,\n            staleBlock,\n            minIndex,\n            length\n        );\n        // We clear any data in the stale region\n        // Note - Since find returns 0 if no stale data is found and we use > instead of >=\n        //        this won't trigger if no stale data is found. Plus it won't trigger on minIndex == staleIndex\n        //        == maxIndex and clear the whole array.\n        if (staleIndex > minIndex) {\n            // Delete the outdated stored info\n            _clear(minIndex, staleIndex, storageData);\n            // Reset the array info with stale index as the new minIndex\n            _setBounds(storageData, staleIndex, length);\n        }\n        return (loadedData);\n    }\n\n    /// @notice Searches for the data stored at the largest blocknumber index less than a provided parameter.\n    ///         Allows specification of a expiration stamp and returns the greatest examined index which is\n    ///         found to be older than that stamp.\n    /// @param data The stored data\n    /// @param blocknumber the blocknumber we want to load the historical data for.\n    /// @param staleBlock The oldest block that we care about the data stored for, all previous data can be deleted\n    /// @param startingMinIndex The smallest filled index in the array\n    /// @param length the length of the array\n    /// @return Returns the largest stale data index seen or 0 for no seen stale data and the stored data\n    function _find(\n        uint256[] storage data,\n        uint256 blocknumber,\n        uint256 staleBlock,\n        uint256 startingMinIndex,\n        uint256 length\n    ) private view returns (uint256, uint256) {\n        // We explicitly revert on the reading of memory which is uninitialized\n        require(length != 0, \"uninitialized\");\n        // Do some correctness checks\n        require(staleBlock <= blocknumber);\n        require(startingMinIndex < length);\n        // Load the bounds of our binary search\n        uint256 maxIndex = length - 1;\n        uint256 minIndex = startingMinIndex;\n        uint256 staleIndex = 0;\n\n        // We run a binary search on the block number fields in the array between\n        // the minIndex and maxIndex. If we find indexes with blocknumber < staleBlock\n        // we set staleIndex to them and return that data for an optional clearing step\n        // in the calling function.\n        while (minIndex != maxIndex) {\n            // We use the ceil instead of the floor because this guarantees that\n            // we pick the highest blocknumber less than or equal the requested one\n            uint256 mid = (minIndex + maxIndex + 1) / 2;\n            // Load and unpack the data in the midpoint index\n            (uint256 pastBlock, uint256 loadedData) = _loadAndUnpack(data, mid);\n\n            //  If we've found the exact block we are looking for\n            if (pastBlock == blocknumber) {\n                // Then we just return the data\n                return (staleIndex, loadedData);\n\n                // Otherwise if the loaded block is smaller than the block number\n            } else if (pastBlock < blocknumber) {\n                // Then we first check if this is possibly a stale block\n                if (pastBlock < staleBlock) {\n                    // If it is we mark it for clearing\n                    staleIndex = mid;\n                }\n                // We then repeat the search logic on the indices greater than the midpoint\n                minIndex = mid;\n\n                // In this case the pastBlock > blocknumber\n            } else {\n                // We then repeat the search on the indices below the midpoint\n                maxIndex = mid - 1;\n            }\n        }\n\n        // We load at the final index of the search\n        (uint256 _pastBlock, uint256 _loadedData) = _loadAndUnpack(\n            data,\n            minIndex\n        );\n        // This will only be hit if a user has misconfigured the stale index and then\n        // tried to load father into the past than has been preserved\n        require(_pastBlock <= blocknumber, \"Search Failure\");\n        return (staleIndex, _loadedData);\n    }\n\n    /// @notice Clears storage between two bounds in array\n    /// @param oldMin The first index to set to zero\n    /// @param newMin The new minimum filled index, ie clears to index < newMin\n    /// @param data The storage array pointer\n    function _clear(\n        uint256 oldMin,\n        uint256 newMin,\n        uint256[] storage data\n    ) private {\n        // Correctness checks on this call\n        require(oldMin <= newMin);\n        // This function is private and trusted and should be only called by functions which ensure\n        // that oldMin < newMin < length\n        assembly {\n            // The layout of arrays in solidity is [length][data]....[data] so this pointer is the\n            // slot to write to data\n            let dataLocation := add(data.slot, 1)\n            // Loop through each index which is below new min and clear the storage\n            // Note - Uses strict min so if given an input like oldMin = 5 newMin = 5 will be a no op\n            for {\n                let i := oldMin\n            } lt(i, newMin) {\n                i := add(i, 1)\n            } {\n                // store at the starting data pointer + i 256 bits of zero\n                sstore(add(dataLocation, i), 0)\n            }\n        }\n    }\n\n    /// @notice Loads and unpacks the block number index and stored data from a data array\n    /// @param data the storage array\n    /// @param i the index to load and unpack\n    /// @return (block number, stored data)\n    function _loadAndUnpack(\n        uint256[] storage data,\n        uint256 i\n    ) private view returns (uint256, uint256) {\n        // This function is trusted and should only be called after checking data lengths\n        // we use assembly for the sload to avoid reloading length.\n        uint256 loaded;\n        assembly {\n            loaded := sload(add(add(data.slot, 1), i))\n        }\n        // Unpack the packed 64 bit block number and 192 bit data field\n        return (\n            loaded >> 192,\n            loaded &\n                0x0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff\n        );\n    }\n\n    /// @notice This function sets our non standard bounds data field where a normal array\n    ///         would have length\n    /// @param data the pointer to the storage array\n    /// @param minIndex The minimum non stale index\n    /// @param length The length of the storage array\n    function _setBounds(\n        uint256[] storage data,\n        uint256 minIndex,\n        uint256 length\n    ) private {\n        // Correctness check\n        require(minIndex < length);\n\n        assembly {\n            // Ensure data cleanliness\n            let clearedLength := and(\n                length,\n                0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff\n            )\n            // We move the min index into the top 128 bits by shifting it left by 128 bits\n            let minInd := shl(128, minIndex)\n            // We pack the data using binary or\n            let packed := or(minInd, clearedLength)\n            // We store in the packed data in the length field of this storage array\n            sstore(data.slot, packed)\n        }\n    }\n\n    /// @notice This function loads and unpacks our packed min index and length for our custom storage array\n    /// @param data The pointer to the storage location\n    /// @return minInd the first filled index in the array\n    /// @return length the length of the array\n    function _loadBounds(\n        uint256[] storage data\n    ) private view returns (uint256 minInd, uint256 length) {\n        // Use assembly to manually load the length storage field\n        uint256 packedData;\n        assembly {\n            packedData := sload(data.slot)\n        }\n        // We use a shift right to clear out the low order bits of the data field\n        minInd = packedData >> 128;\n        // We use a binary and to extract only the bottom 128 bits\n        length =\n            packedData &\n            0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\n    }\n}\n"
    },
    "contracts/libraries/ReentrancyBlock.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\ncontract ReentrancyBlock {\n    // A storage slot for the reentrancy flag\n    bool private _entered;\n    // Will use a state flag to prevent this function from being called back into\n    modifier nonReentrant() {\n        // Check the state variable before the call is entered\n        require(!_entered, \"Reentrancy\");\n        // Store that the function has been entered\n        _entered = true;\n        // Run the function code\n        _;\n        // Clear the state\n        _entered = false;\n    }\n}\n"
    },
    "contracts/libraries/Storage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\n// This library allows for secure storage pointers across proxy implementations\n// It will return storage pointers based on a hashed name and type string.\nlibrary Storage {\n    // This library follows a pattern which if solidity had higher level\n    // type or macro support would condense quite a bit.\n\n    // Each basic type which does not support storage locations is encoded as\n    // a struct of the same name capitalized and has functions 'load' and 'set'\n    // which load the data and set the data respectively.\n\n    // All types will have a function of the form 'typename'Ptr('name') -> storage ptr\n    // which will return a storage version of the type with slot which is the hash of\n    // the variable name and type string. This pointer allows easy state management between\n    // upgrades and overrides the default solidity storage slot system.\n\n    /// @dev The address type container\n    struct Address {\n        address data;\n    }\n\n    /// @notice A function which turns a variable name for a storage address into a storage\n    ///         pointer for its container.\n    /// @param name the variable name\n    /// @return data the storage pointer\n    function addressPtr(\n        string memory name\n    ) internal pure returns (Address storage data) {\n        bytes32 typehash = keccak256(\"address\");\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\n        assembly {\n            data.slot := offset\n        }\n    }\n\n    /// @notice A function to load an address from the container struct\n    /// @param input the storage pointer for the container\n    /// @return the loaded address\n    function load(Address storage input) internal view returns (address) {\n        return input.data;\n    }\n\n    /// @notice A function to set the internal field of an address container\n    /// @param input the storage pointer to the container\n    /// @param to the address to set the container to\n    function set(Address storage input, address to) internal {\n        input.data = to;\n    }\n\n    /// @dev The uint256 type container\n    struct Uint256 {\n        uint256 data;\n    }\n\n    /// @notice A function which turns a variable name for a storage uint256 into a storage\n    ///         pointer for its container.\n    /// @param name the variable name\n    /// @return data the storage pointer\n    function uint256Ptr(\n        string memory name\n    ) internal pure returns (Uint256 storage data) {\n        bytes32 typehash = keccak256(\"uint256\");\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\n        assembly {\n            data.slot := offset\n        }\n    }\n\n    /// @notice A function to load an uint256 from the container struct\n    /// @param input the storage pointer for the container\n    /// @return the loaded uint256\n    function load(Uint256 storage input) internal view returns (uint256) {\n        return input.data;\n    }\n\n    /// @notice A function to set the internal field of a unit256 container\n    /// @param input the storage pointer to the container\n    /// @param to the address to set the container to\n    function set(Uint256 storage input, uint256 to) internal {\n        input.data = to;\n    }\n\n    /// @notice Returns the storage pointer for a named mapping of address to uint256\n    /// @param name the variable name for the pointer\n    /// @return data the mapping pointer\n    function mappingAddressToUnit256Ptr(\n        string memory name\n    ) internal pure returns (mapping(address => uint256) storage data) {\n        bytes32 typehash = keccak256(\"mapping(address => uint256)\");\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\n        assembly {\n            data.slot := offset\n        }\n    }\n\n    /// @notice Returns the storage pointer for a named mapping of address to uint256[]\n    /// @param name the variable name for the pointer\n    /// @return data the mapping pointer\n    function mappingAddressToUnit256ArrayPtr(\n        string memory name\n    ) internal pure returns (mapping(address => uint256[]) storage data) {\n        bytes32 typehash = keccak256(\"mapping(address => uint256[])\");\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\n        assembly {\n            data.slot := offset\n        }\n    }\n\n    /// @notice Returns the storage pointer for a named mapping of address to int24[]\n    /// @param name the variable name for the pointer\n    /// @return data the mapping pointer\n    function mappingAddressToInt256ArrayPtr(\n        string memory name\n    ) internal pure returns (mapping(address => int256[]) storage data) {\n        bytes32 typehash = keccak256(\"mapping(address => int256[])\");\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\n        assembly {\n            data.slot := offset\n        }\n    }\n\n    /// @notice Allows external users to calculate the slot given by this lib\n    /// @param typeString the string which encodes the type\n    /// @param name the variable name\n    /// @return the slot assigned by this lib\n    function getPtr(\n        string memory typeString,\n        string memory name\n    ) external pure returns (uint256) {\n        bytes32 typehash = keccak256(abi.encodePacked(typeString));\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\n        return (uint256)(offset);\n    }\n\n    // A struct which represents 1 packed storage location with a compressed\n    // address and uint96 pair\n    struct AddressUint {\n        address who;\n        uint96 amount;\n    }\n\n    /// @notice Returns the storage pointer for a named mapping of address to uint256[]\n    /// @param name the variable name for the pointer\n    /// @return data the mapping pointer\n    function mappingAddressToPackedAddressUint(\n        string memory name\n    ) internal pure returns (mapping(address => AddressUint) storage data) {\n        bytes32 typehash = keccak256(\"mapping(address => AddressUint)\");\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\n        assembly {\n            data.slot := offset\n        }\n    }\n}\n"
    },
    "contracts/libraries/VestingVaultStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\n// Copy of `Storage` with modified scope to match the VestingVault requirements\n// This library allows for secure storage pointers across proxy implementations\n// It will return storage pointers based on a hashed name and type string.\nlibrary VestingVaultStorage {\n    // This library follows a pattern which if solidity had higher level\n    // type or macro support would condense quite a bit.\n\n    // Each basic type which does not support storage locations is encoded as\n    // a struct of the same name capitalized and has functions 'load' and 'set'\n    // which load the data and set the data respectively.\n\n    // All types will have a function of the form 'typename'Ptr('name') -> storage ptr\n    // which will return a storage version of the type with slot which is the hash of\n    // the variable name and type string. This pointer allows easy state management between\n    // upgrades and overrides the default solidity storage slot system.\n\n    // A struct which represents 1 packed storage location (Grant)\n    struct Grant {\n        uint128 allocation;\n        uint128 withdrawn;\n        uint128 created;\n        uint128 expiration;\n        uint128 cliff;\n        uint128 latestVotingPower;\n        address delegatee;\n        uint256[2] range;\n    }\n\n    /// @notice Returns the storage pointer for a named mapping of address to uint256[]\n    /// @param name the variable name for the pointer\n    /// @return data the mapping pointer\n    function mappingAddressToGrantPtr(\n        string memory name\n    ) internal pure returns (mapping(address => Grant) storage data) {\n        bytes32 typehash = keccak256(\"mapping(address => Grant)\");\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\n        assembly {\n            data.slot := offset\n        }\n    }\n}\n"
    },
    "contracts/mockHog.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n// taken from our contracts repo\n\nimport \"./libraries/ERC20PermitWithMint.sol\";\n\npragma solidity ^0.8.3;\n\ncontract MockHog is ERC20PermitWithMint {\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address owner_\n    ) ERC20PermitWithMint(name_, symbol_, owner_) {}\n\n    function setBalance(address who, uint256 amount) external {\n        balanceOf[who] = amount;\n    }\n\n    function setAllowance(\n        address source,\n        address spender,\n        uint256 amount\n    ) external {\n        allowance[source][spender] = amount;\n    }\n}\n"
    },
    "contracts/mockWeth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n// taken from our contracts repo\n\nimport \"./libraries/ERC20PermitWithMint.sol\";\n\npragma solidity ^0.8.3;\n\ncontract MockWeth is ERC20PermitWithMint {\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address owner_\n    ) ERC20PermitWithMint(name_, symbol_, owner_) {}\n\n    function setBalance(address who, uint256 amount) external {\n        balanceOf[who] = amount;\n    }\n\n    function setAllowance(\n        address source,\n        address spender,\n        uint256 amount\n    ) external {\n        allowance[source][spender] = amount;\n    }\n}\n"
    },
    "contracts/simpleProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\ncontract SimpleProxy {\n    // This contract splits the storage of a contract from its logic, it will\n    // call an implementation contract via delegatecall. That implementation\n    // changes what is stored in this contract, by changing the implementation\n    // address this contract effectively has different logic.\n\n    // NOTE - Functions 'upgradeProxy', 'resetProxyOwner', 'proxyImplementation' and 'proxyGovernance'\n    // are occupied namespace and cannot be used in implementation contracts. In a very unlikely\n    // edge case a 4 bit hash collision between function selectors could block other function names.\n\n    // The implementation contains the logic for this proxy, it for security reasons\n    // should not assume only this contract can call it.\n    // NOTE - It's insecure in implementation proxies to use the default storage layout since\n    //        it is possible to overwrite this address. Use Storage.sol for storage.\n    address public proxyImplementation;\n    // The address which can upgrade this contract\n    address public proxyGovernance;\n\n    /// @notice Sets up the authorizable library for the proxy\n    /// @param _governance An address which will be authorized to change the implementation\n    ///                    it will also be set at the owner of this contract.\n    /// @param _firstImplementation The first implementation address\n    constructor(address _governance, address _firstImplementation) {\n        // Set governance\n        proxyGovernance = _governance;\n        // Set the first implementation\n        proxyImplementation = _firstImplementation;\n    }\n\n    /// @notice Allows authorized addresses to change the implementation\n    /// @param _newImplementation The new implementation address\n    function upgradeProxy(address _newImplementation) external {\n        require(msg.sender == proxyGovernance, \"unauthorized\");\n        proxyImplementation = _newImplementation;\n    }\n\n    /// @notice Sets the address which can upgrade this proxy, only callable\n    ///         by the current address which can upgrade this proxy.\n    /// @param _newGovernance The new governance address\n    function resetProxyOwner(address _newGovernance) external {\n        require(msg.sender == proxyGovernance, \"unauthorized\");\n        proxyGovernance = _newGovernance;\n    }\n\n    /// @notice The fallback is the routing function for the proxy and uses delegatecall\n    ///         to forward any calls which are made to this address to be executed by the\n    ///         logic contract.\n    /// @dev WARNING - We don't do extcode size checks like high level solidity if the\n    ///                implementation has 0 bytecode this will succeed but do nothing.\n    fallback() external payable {\n        assembly {\n            let calldataLength := calldatasize()\n\n            // equivalent to receive() external payable {}\n            if iszero(calldataLength) {\n                return(0, 0)\n            }\n\n            // We load the free memory pointer\n            // Note - We technically don't need to do this because the whole call is\n            // in assembly but it's good practice to match solidity's memory management\n            let ptr := mload(0x40)\n            // Copy the calldata into memory\n            calldatacopy(\n                // The position in memory this copies to\n                ptr,\n                // The calldata index this copies from\n                0,\n                // The number of bytes to copy\n                calldataLength\n            )\n            // Move the free memory pointer\n            mstore(0x40, add(ptr, calldataLength))\n            // Load the implementation address\n            let implementation := sload(proxyImplementation.slot)\n            // It's very unlikely any extra data got loaded but we clean anyway\n            implementation := and(\n                implementation,\n                0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            )\n            // Now we make the delegatecall\n            let success := delegatecall(\n                // The gas param\n                gas(),\n                // The address\n                implementation,\n                // The memory location of the input data\n                ptr,\n                // The input size\n                calldataLength,\n                // The output memory pointer and size, we use the return data instead\n                0,\n                0\n            )\n            // Load our new free memory pointer\n            ptr := mload(0x40)\n            // Load the return data size\n            let returndataLength := returndatasize()\n            // Copy the return data\n            returndatacopy(\n                // Memory location of the output\n                ptr,\n                // Memory location of the input\n                0,\n                // Length of the input\n                returndataLength\n            )\n            // If the call was not successful we revert\n            if iszero(success) {\n                revert(ptr, returndataLength)\n            }\n\n            // If the call was successful we return\n            return(ptr, returndataLength)\n        }\n    }\n}\n"
    },
    "contracts/vaults/FriendlyVault.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../libraries/History.sol\";\nimport \"../libraries/VestingVaultStorage.sol\";\nimport \"../libraries/Storage.sol\";\nimport \"../interfaces/IVotingVault.sol\";\nimport \"@aave/core-v3/contracts/mocks/tokens/MintableERC20.sol\";\n\ncontract FriendlyVault is IVotingVault {\n    // extraData encodes a uint128 of votes to give to the user via abi.encode\n    function queryVotePower(\n        address user,\n        uint256 blockNumber,\n        bytes calldata extraData\n    ) external override returns (uint256) {\n        uint128 votes = abi.decode(extraData, (uint128));\n        return uint256(votes);\n    }\n}\n"
    },
    "contracts/vaults/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.3;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"
    },
    "contracts/vaults/IVotingVault.sol": {
      "content": "interface IVotingVault {\n    /// @notice Attempts to load the voting power of a user\n    /// @param user The address we want to load the voting power of\n    /// @param blockNumber the block number we want the user's voting power at\n    /// @param extraData Abi encoded optional extra data used by some vaults, such as merkle proofs\n    /// @return the number of votes\n    function queryVotePower(\n        address user,\n        uint256 blockNumber,\n        bytes calldata extraData\n    ) external returns (uint256);\n}\n"
    },
    "contracts/vaults/V3Vault.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\nimport \"../libraries/History.sol\";\nimport \"../libraries/Storage.sol\";\nimport \"./IERC721.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"./IVotingVault.sol\";\nimport \"../interfaces/INonfungiblePositionManager.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\n\ncontract V3Vault is IVotingVault {\n    // Bring our libraries into scope\n    using History for *;\n    using Storage for *;\n\n    // Only immutables can be declared without using the hash locations\n    IERC721 immutable token;\n    IERC20 immutable govToken;\n    IERC20 immutable weth;\n    uint24 immutable feeTier;\n    INonfungiblePositionManager immutable NFTPositionManager;\n    IUniswapV3Factory immutable Factory;\n\n    constructor(\n        IERC721 _token,\n        IERC20 _govToken,\n        IERC20 _weth,\n        uint24 _feeTier,\n        INonfungiblePositionManager _NFTPositionManager,\n        IUniswapV3Factory _Factory\n    ) {\n        token = _token;\n        govToken = _govToken;\n        weth = _weth;\n        feeTier = _feeTier;\n        NFTPositionManager = _NFTPositionManager;\n        Factory = _Factory;\n    }\n\n    /// @notice Returns the historical voting power tracker\n    /// @return A struct which can push to and find items in block indexed storage\n    function _votingPower()\n        internal\n        pure\n        returns (History.HistoricalBalances memory)\n    {\n        // This call returns a storage mapping with a unique non overwrite-able storage location\n        // which can be persisted through upgrades, even if they change storage layout\n        return (History.load(\"votingPower\"));\n    }\n\n    /// @notice Transfers one NFT of our collection to this contract and then adds one vote to the user's voting power\n    /// @param tokenId The token Id, not the NFT to transfer.\n    function deposit(uint256 tokenId) external {\n        // Get the token from the user\n        token.transferFrom(msg.sender, address(this), tokenId);\n        // Get the hash pointer to the history mapping\n        History.HistoricalBalances memory votingPower = _votingPower();\n        // Load the user votes\n        uint256 currentVotes = votingPower.loadTop(msg.sender);\n        // Push their new voting power\n        votingPower.push(msg.sender, currentVotes + 1);\n    }\n\n    struct posInfo {\n        address desiredPool;\n        int24 centerTick;\n        int24 width;\n        address userToken;\n        uint256 token0AmountDesired;\n        uint256 token1AmountDesired;\n    }\n\n    function viewUserPosition(uint256 index) external returns (uint256) {\n        mapping(address => uint256[]) storage userData = Storage\n            .mappingAddressToUnit256ArrayPtr(\"userPositions\");\n        return userData[msg.sender][index];\n    }\n\n    function mintPosition(posInfo memory v3Info) external {\n        // Get the token from the user\n\n        IERC20(IUniswapV3Pool(v3Info.desiredPool).token0()).transferFrom(\n            msg.sender,\n            address(this),\n            v3Info.token0AmountDesired\n        );\n        IERC20(IUniswapV3Pool(v3Info.desiredPool).token1()).transferFrom(\n            msg.sender,\n            address(this),\n            v3Info.token1AmountDesired\n        );\n\n        bool suc = IERC20(IUniswapV3Pool(v3Info.desiredPool).token0()).approve(\n            address(NFTPositionManager),\n            v3Info.token0AmountDesired\n        );\n        require(suc);\n        bool suc2 = IERC20(IUniswapV3Pool(v3Info.desiredPool).token1()).approve(\n            address(NFTPositionManager),\n            v3Info.token1AmountDesired\n        );\n        require(suc2);\n\n        INonfungiblePositionManager.MintParams\n            memory params = INonfungiblePositionManager.MintParams({\n                token0: IUniswapV3Pool(v3Info.desiredPool).token0(),\n                token1: IUniswapV3Pool(v3Info.desiredPool).token1(),\n                fee: feeTier,\n                tickLower: v3Info.centerTick -\n                    v3Info.width *\n                    IUniswapV3Pool(v3Info.desiredPool).tickSpacing(),\n                tickUpper: v3Info.centerTick +\n                    v3Info.width *\n                    IUniswapV3Pool(v3Info.desiredPool).tickSpacing(),\n                amount0Desired: v3Info.token0AmountDesired,\n                amount1Desired: v3Info.token1AmountDesired,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp + 1000000\n            });\n        //Need to develop a slippage estimation process\n        (uint256 tokenId, uint128 liquidity, , ) = NFTPositionManager.mint(\n            params\n        );\n        mapping(address => uint256[]) storage userData = Storage\n            .mappingAddressToUnit256ArrayPtr(\"userPositions\");\n        userData[msg.sender].push(tokenId);\n        // Get the hash pointer to the history mapping\n        History.HistoricalBalances memory votingPower = _votingPower();\n        // Load the user votes\n        uint256 currentVotes = votingPower.loadTop(msg.sender);\n        // Push their new voting power\n\n        votingPower.push(msg.sender, currentVotes + 1);\n\n        mapping(address => int256[]) storage data = Storage\n            .mappingAddressToInt256ArrayPtr(\"userOwnerShip\");\n\n        data[msg.sender].push(int128(liquidity));\n        data[msg.sender].push(\n            v3Info.centerTick -\n                v3Info.width *\n                IUniswapV3Pool(v3Info.desiredPool).tickSpacing()\n        );\n        data[msg.sender].push(\n            v3Info.centerTick +\n                v3Info.width *\n                IUniswapV3Pool(v3Info.desiredPool).tickSpacing()\n        );\n    }\n\n    /// @notice Attempts to load the voting power of a user\n    /// @param user The address we want to load the voting power of\n    /// @param blockNumber the block number at which we want the user's voting power\n    /// @return the number of votes\n    function queryVotePower(\n        address user,\n        uint256 blockNumber,\n        bytes calldata //This can be the current V3\n    ) external view override returns (uint256) {\n        History.HistoricalBalances memory votingPower = _votingPower();\n        // Get our reference to historical data\n\n        uint256 farthestSearchableIndex = votingPower.find(user, blockNumber);\n\n        mapping(address => int256[]) storage data = Storage\n            .mappingAddressToInt256ArrayPtr(\"userOwnerShip\");\n        // Find the historical data in our mapping\n        address pool = Factory.getPool(\n            address(govToken),\n            address(weth),\n            feeTier\n        );\n        (, int24 currentTick, , , , , ) = IUniswapV3Pool(pool).slot0();\n\n        uint256 i = 0;\n        uint256 votingPowerTotal = 0;\n        while (i < farthestSearchableIndex * 3) {\n            if (data[msg.sender][i + 1] > currentTick) {\n                //If the lower one is above the currentTick\n                i = i + 3;\n                continue;\n            }\n            if (data[msg.sender][i + 2] < currentTick) {\n                //If the lower one is above the currentTick\n                i = i + 3;\n                continue;\n            }\n            votingPowerTotal += uint256(data[msg.sender][i]);\n            i = i + 3;\n        }\n        return votingPowerTotal;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}