{
  "address": "0x90770d8950fc41160a01b9d15dcfcF8E30cc0799",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "blockNumber",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "queryVotePower",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x2e996ffac337c56f737ceece384dea4c1762359a51e7d94c37d6c9fb42736967",
  "receipt": {
    "to": null,
    "from": "0x19d96301865fdD07427db3c445508A051BC6D352",
    "contractAddress": "0x90770d8950fc41160a01b9d15dcfcF8E30cc0799",
    "transactionIndex": 39,
    "gasUsed": "133123",
    "logsBloom": "0x00000000000000000000004000000000000000000000000000000000000000000000000000000000000000000002000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000800000000000000000000000040000000000000000200000000000004000000000000000000000000000000000000000000000004000000000000000000001000000040000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x91c572650577785a6ff7129cdf697ccefb85120fbe1986fd73be0521acedfb86",
    "transactionHash": "0x2e996ffac337c56f737ceece384dea4c1762359a51e7d94c37d6c9fb42736967",
    "logs": [
      {
        "transactionIndex": 39,
        "blockNumber": 44304297,
        "transactionHash": "0x2e996ffac337c56f737ceece384dea4c1762359a51e7d94c37d6c9fb42736967",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x00000000000000000000000019d96301865fdd07427db3c445508a051bc6d352",
          "0x000000000000000000000000a8b52f02108aa5f4b675bdcc973760022d7c6020"
        ],
        "data": "0x000000000000000000000000000000000000000000000000000e303d69cb040000000000000000000000000000000000000000000000000029131f9ebb539ffe00000000000000000000000000000000000000000000008ffce3a43c64b35a300000000000000000000000000000000000000000000000002904ef6151889bfe00000000000000000000000000000000000000000000008ffcf1d479ce7e5e30",
        "logIndex": 199,
        "blockHash": "0x91c572650577785a6ff7129cdf697ccefb85120fbe1986fd73be0521acedfb86"
      }
    ],
    "blockNumber": 44304297,
    "cumulativeGasUsed": "9189394",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "de8a9e6671cf44320fb449edaa342a2d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"queryVotePower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"queryVotePower(address,uint256,bytes)\":{\"params\":{\"blockNumber\":\"the block number we want the user's voting power at\",\"extraData\":\"Abi encoded optional extra data used by some vaults, such as merkle proofs\",\"user\":\"The address we want to load the voting power of\"},\"returns\":{\"_0\":\"the number of votes\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"queryVotePower(address,uint256,bytes)\":{\"notice\":\"Attempts to load the voting power of a user\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/vaults/FriendlyVault.sol\":\"FriendlyVault\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/Address.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.10;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      codehash := extcodehash(account)\\n    }\\n    return (codehash != accountHash && codehash != 0x0);\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\n  }\\n}\\n\",\"keccak256\":\"0xc66110540bf2c6eec38e080c21cb66edb60d7d0af43dbbb51ee8bc146b5c9d23\",\"license\":\"AGPL-3.0\"},\"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return payable(msg.sender);\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\",\"keccak256\":\"0x0d984665e4f3dd200c605a83b7caae057dd96136c038fcdd271fd85757dc3d8f\",\"license\":\"MIT\"},\"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport './Context.sol';\\nimport './IERC20.sol';\\nimport './SafeMath.sol';\\nimport './Address.sol';\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n\\n  /**\\n   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n   * a default value of 18.\\n   *\\n   * To select a different value for {decimals}, use {_setupDecimals}.\\n   *\\n   * All three of these values are immutable: they can only be set once during\\n   * construction.\\n   */\\n  constructor(string memory name, string memory symbol) {\\n    _name = name;\\n    _symbol = symbol;\\n    _decimals = 18;\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() public view returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token, usually a shorter version of the\\n   * name.\\n   */\\n  function symbol() public view returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals used to get its user representation.\\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n   *\\n   * Tokens usually opt for a value of 18, imitating the relationship between\\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n   * called.\\n   *\\n   * NOTE: This information is only used for _display_ purposes: it in\\n   * no way affects any of the arithmetic of the contract, including\\n   * {IERC20-balanceOf} and {IERC20-transfer}.\\n   */\\n  function decimals() public view returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-totalSupply}.\\n   */\\n  function totalSupply() public view override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-balanceOf}.\\n   */\\n  function balanceOf(address account) public view override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev See {IERC20-transfer}.\\n   *\\n   * Requirements:\\n   *\\n   * - `recipient` cannot be the zero address.\\n   * - the caller must have a balance of at least `amount`.\\n   */\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-allowance}.\\n   */\\n  function allowance(\\n    address owner,\\n    address spender\\n  ) public view virtual override returns (uint256) {\\n    return _allowances[owner][spender];\\n  }\\n\\n  /**\\n   * @dev See {IERC20-approve}.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n    _approve(_msgSender(), spender, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-transferFrom}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance. This is not\\n   * required by the EIP. See the note at the beginning of {ERC20};\\n   *\\n   * Requirements:\\n   * - `sender` and `recipient` cannot be the zero address.\\n   * - `sender` must have a balance of at least `amount`.\\n   * - the caller must have allowance for ``sender``'s tokens of at least\\n   * `amount`.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n    _approve(\\n      sender,\\n      _msgSender(),\\n      _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance')\\n    );\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {IERC20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {IERC20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   * - `spender` must have allowance for the caller of at least\\n   * `subtractedValue`.\\n   */\\n  function decreaseAllowance(\\n    address spender,\\n    uint256 subtractedValue\\n  ) public virtual returns (bool) {\\n    _approve(\\n      _msgSender(),\\n      spender,\\n      _allowances[_msgSender()][spender].sub(\\n        subtractedValue,\\n        'ERC20: decreased allowance below zero'\\n      )\\n    );\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\\n   *\\n   * This is internal function is equivalent to {transfer}, and can be used to\\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\\n   *\\n   * Emits a {Transfer} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `sender` cannot be the zero address.\\n   * - `recipient` cannot be the zero address.\\n   * - `sender` must have a balance of at least `amount`.\\n   */\\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n    require(sender != address(0), 'ERC20: transfer from the zero address');\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n    _beforeTokenTransfer(sender, recipient, amount);\\n\\n    _balances[sender] = _balances[sender].sub(amount, 'ERC20: transfer amount exceeds balance');\\n    _balances[recipient] = _balances[recipient].add(amount);\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n   * the total supply.\\n   *\\n   * Emits a {Transfer} event with `from` set to the zero address.\\n   *\\n   * Requirements\\n   *\\n   * - `to` cannot be the zero address.\\n   */\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: mint to the zero address');\\n\\n    _beforeTokenTransfer(address(0), account, amount);\\n\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the\\n   * total supply.\\n   *\\n   * Emits a {Transfer} event with `to` set to the zero address.\\n   *\\n   * Requirements\\n   *\\n   * - `account` cannot be the zero address.\\n   * - `account` must have at least `amount` tokens.\\n   */\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: burn from the zero address');\\n\\n    _beforeTokenTransfer(account, address(0), amount);\\n\\n    _balances[account] = _balances[account].sub(amount, 'ERC20: burn amount exceeds balance');\\n    _totalSupply = _totalSupply.sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n   *\\n   * This is internal function is equivalent to `approve`, and can be used to\\n   * e.g. set automatic allowances for certain subsystems, etc.\\n   *\\n   * Emits an {Approval} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `owner` cannot be the zero address.\\n   * - `spender` cannot be the zero address.\\n   */\\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\\n    require(owner != address(0), 'ERC20: approve from the zero address');\\n    require(spender != address(0), 'ERC20: approve to the zero address');\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n\\n  /**\\n   * @dev Sets {decimals} to a value other than the default one of 18.\\n   *\\n   * WARNING: This function should only be called from the constructor. Most\\n   * applications that interact with token contracts will not expect\\n   * {decimals} to ever change, and may work incorrectly if it does.\\n   */\\n  function _setupDecimals(uint8 decimals_) internal {\\n    _decimals = decimals_;\\n  }\\n\\n  /**\\n   * @dev Hook that is called before any transfer of tokens. This includes\\n   * minting and burning.\\n   *\\n   * Calling conditions:\\n   *\\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n   * will be to transferred to `to`.\\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n   * - `from` and `to` are never both zero.\\n   *\\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n   */\\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\",\"keccak256\":\"0x0c8026ecea99985f936ba3330a699aa8c906a444102188c8e335f4c29d828f04\",\"license\":\"MIT\"},\"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xf57d62241e553696a1324d225663ba2e1a51db0a51ca236d0c1b009d89b6284c\",\"license\":\"AGPL-3.0\"},\"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.10;\\n\\n/// @title Optimized overflow and underflow safe math operations\\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\\nlibrary SafeMath {\\n  /// @notice Returns x + y, reverts if sum overflows uint256\\n  /// @param x The augend\\n  /// @param y The addend\\n  /// @return z The sum of x and y\\n  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    unchecked {\\n      require((z = x + y) >= x);\\n    }\\n  }\\n\\n  /// @notice Returns x - y, reverts if underflows\\n  /// @param x The minuend\\n  /// @param y The subtrahend\\n  /// @return z The difference of x and y\\n  function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    unchecked {\\n      require((z = x - y) <= x);\\n    }\\n  }\\n\\n  /// @notice Returns x - y, reverts if underflows\\n  /// @param x The minuend\\n  /// @param y The subtrahend\\n  /// @param message The error msg\\n  /// @return z The difference of x and y\\n  function sub(uint256 x, uint256 y, string memory message) internal pure returns (uint256 z) {\\n    unchecked {\\n      require((z = x - y) <= x, message);\\n    }\\n  }\\n\\n  /// @notice Returns x * y, reverts if overflows\\n  /// @param x The multiplicand\\n  /// @param y The multiplier\\n  /// @return z The product of x and y\\n  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    unchecked {\\n      require(x == 0 || (z = x * y) / x == y);\\n    }\\n  }\\n\\n  /// @notice Returns x / y, reverts if overflows - no specific check, solidity reverts on division by 0\\n  /// @param x The numerator\\n  /// @param y The denominator\\n  /// @return z The product of x and y\\n  function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    return x / y;\\n  }\\n}\\n\",\"keccak256\":\"0x4223648ac13d8ab127510c437f0805e1fc62dc399549751fed4613d2e5f40ff4\",\"license\":\"AGPL-3.0\"},\"@aave/core-v3/contracts/interfaces/IERC20WithPermit.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\\n\\n/**\\n * @title IERC20WithPermit\\n * @author Aave\\n * @notice Interface for the permit function (EIP-2612)\\n */\\ninterface IERC20WithPermit is IERC20 {\\n  /**\\n   * @notice Allow passing a signed message to approve spending\\n   * @dev implements the permit function as for\\n   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\\n   * @param owner The owner of the funds\\n   * @param spender The spender\\n   * @param value The amount\\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\\n   * @param v Signature param\\n   * @param s Signature param\\n   * @param r Signature param\\n   */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n}\\n\",\"keccak256\":\"0xfb041570f1804648f543be72cecc80ca9f65129232bacaa9247ebd11a7d9f83e\",\"license\":\"AGPL-3.0\"},\"@aave/core-v3/contracts/mocks/tokens/MintableERC20.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.10;\\n\\nimport {ERC20} from '../../dependencies/openzeppelin/contracts/ERC20.sol';\\nimport {IERC20WithPermit} from '../../interfaces/IERC20WithPermit.sol';\\n\\n/**\\n * @title ERC20Mintable\\n * @dev ERC20 minting logic\\n */\\ncontract MintableERC20 is IERC20WithPermit, ERC20 {\\n  bytes public constant EIP712_REVISION = bytes('1');\\n  bytes32 internal constant EIP712_DOMAIN =\\n    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\\n  bytes32 public constant PERMIT_TYPEHASH =\\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\\n\\n  // Map of address nonces (address => nonce)\\n  mapping(address => uint256) internal _nonces;\\n\\n  bytes32 public DOMAIN_SEPARATOR;\\n\\n  constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol) {\\n    uint256 chainId = block.chainid;\\n\\n    DOMAIN_SEPARATOR = keccak256(\\n      abi.encode(\\n        EIP712_DOMAIN,\\n        keccak256(bytes(name)),\\n        keccak256(EIP712_REVISION),\\n        chainId,\\n        address(this)\\n      )\\n    );\\n    _setupDecimals(decimals);\\n  }\\n\\n  /// @inheritdoc IERC20WithPermit\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external override {\\n    require(owner != address(0), 'INVALID_OWNER');\\n    //solium-disable-next-line\\n    require(block.timestamp <= deadline, 'INVALID_EXPIRATION');\\n    uint256 currentValidNonce = _nonces[owner];\\n    bytes32 digest = keccak256(\\n      abi.encodePacked(\\n        '\\\\x19\\\\x01',\\n        DOMAIN_SEPARATOR,\\n        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))\\n      )\\n    );\\n    require(owner == ecrecover(digest, v, r, s), 'INVALID_SIGNATURE');\\n    _nonces[owner] = currentValidNonce + 1;\\n    _approve(owner, spender, value);\\n  }\\n\\n  /**\\n   * @dev Function to mint tokens\\n   * @param value The amount of tokens to mint.\\n   * @return A boolean that indicates if the operation was successful.\\n   */\\n  function mint(uint256 value) public returns (bool) {\\n    _mint(_msgSender(), value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Function to mint tokens to address\\n   * @param account The account to mint tokens.\\n   * @param value The amount of tokens to mint.\\n   * @return A boolean that indicates if the operation was successful.\\n   */\\n  function mint(address account, uint256 value) public returns (bool) {\\n    _mint(account, value);\\n    return true;\\n  }\\n\\n  function nonces(address owner) public view virtual returns (uint256) {\\n    return _nonces[owner];\\n  }\\n}\\n\",\"keccak256\":\"0x992b4f3ce1d6894506f63faed220a2dafe8c4eee748049d14662ce615be3f40d\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    // Note this is non standard but nearly all ERC20 have exposed decimal functions\\n    function decimals() external view returns (uint8);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\",\"keccak256\":\"0x18060ccebc31bddae9913849a36d44f7310268020741ff958afb6e1d97086404\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/IVotingVault.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\ninterface IVotingVault {\\n    /// @notice Attempts to load the voting power of a user\\n    /// @param user The address we want to load the voting power of\\n    /// @param blockNumber the block number we want the user's voting power at\\n    /// @param extraData Abi encoded optional extra data used by some vaults, such as merkle proofs\\n    /// @return the number of votes\\n    function queryVotePower(\\n        address user,\\n        uint256 blockNumber,\\n        bytes calldata extraData\\n    ) external returns (uint256);\\n}\\n\",\"keccak256\":\"0xee4f5603f12cd949a90f5e16cfbcb6d6b6d3b0c1b351ce639885c231e4bcf389\",\"license\":\"Apache-2.0\"},\"contracts/libraries/History.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\nimport \\\"./Storage.sol\\\";\\n\\n// This library is an assembly optimized storage library which is designed\\n// to track timestamp history in a struct which uses hash derived pointers.\\n// WARNING - Developers using it should not access the underlying storage\\n// directly since we break some assumptions of high level solidity. Please\\n// note this library also increases the risk profile of memory manipulation\\n// please be cautious in your usage of uninitialized memory structs and other\\n// anti patterns.\\nlibrary History {\\n    // The storage layout of the historical array looks like this\\n    // [(128 bit min index)(128 bit length)] [0][0] ... [(64 bit block num)(192 bit data)] .... [(64 bit block num)(192 bit data)]\\n    // We give the option to the invoker of the search function the ability to clear\\n    // stale storage. To find data we binary search for the block number we need\\n    // This library expects the blocknumber indexed data to be pushed in ascending block number\\n    // order and if data is pushed with the same blocknumber it only retains the most recent.\\n    // This ensures each blocknumber is unique and contains the most recent data at the end\\n    // of whatever block it indexes [as long as that block is not the current one].\\n\\n    // A struct which wraps a memory pointer to a string and the pointer to storage\\n    // derived from that name string by the storage library\\n    // WARNING - For security purposes never directly construct this object always use load\\n    struct HistoricalBalances {\\n        string name;\\n        // Note - We use bytes32 to reduce how easy this is to manipulate in high level sol\\n        bytes32 cachedPointer;\\n    }\\n\\n    /// @notice The method by which inheriting contracts init the HistoricalBalances struct\\n    /// @param name The name of the variable. Note - these are globals, any invocations of this\\n    ///             with the same name work on the same storage.\\n    /// @return The memory pointer to the wrapper of the storage pointer\\n    function load(\\n        string memory name\\n    ) internal pure returns (HistoricalBalances memory) {\\n        mapping(address => uint256[]) storage storageData = Storage\\n            .mappingAddressToUnit256ArrayPtr(name);\\n        bytes32 pointer;\\n        assembly {\\n            pointer := storageData.slot\\n        }\\n        return HistoricalBalances(name, pointer);\\n    }\\n\\n    /// @notice An unsafe method of attaching the cached ptr in a historical balance memory objects\\n    /// @param pointer cached pointer to storage\\n    /// @return storageData A storage array mapping pointer\\n    /// @dev PLEASE DO NOT USE THIS METHOD WITHOUT SERIOUS REVIEW. IF AN EXTERNAL ACTOR CAN CALL THIS WITH\\n    //       ARBITRARY DATA THEY MAY BE ABLE TO OVERWRITE ANY STORAGE IN THE CONTRACT.\\n    function _getMapping(\\n        bytes32 pointer\\n    ) private pure returns (mapping(address => uint256[]) storage storageData) {\\n        assembly {\\n            storageData.slot := pointer\\n        }\\n    }\\n\\n    /// @notice This function adds a block stamp indexed piece of data to a historical data array\\n    ///         To prevent duplicate entries if the top of the array has the same blocknumber\\n    ///         the value is updated instead\\n    /// @param wrapper The wrapper which hold the reference to the historical data storage pointer\\n    /// @param who The address which indexes the array we need to push to\\n    /// @param data The data to append, should be at most 192 bits and will revert if not\\n    function push(\\n        HistoricalBalances memory wrapper,\\n        address who,\\n        uint256 data\\n    ) internal {\\n        // Check preconditions\\n        // OoB = Out of Bounds, short for contract bytecode size reduction\\n        require(data <= type(uint192).max, \\\"OoB\\\");\\n        // Get the storage this is referencing\\n        mapping(address => uint256[]) storage storageMapping = _getMapping(\\n            wrapper.cachedPointer\\n        );\\n        // Get the array we need to push to\\n        uint256[] storage storageData = storageMapping[who];\\n        // We load the block number and then shift it to be in the top 64 bits\\n        uint256 blockNumber = block.number << 192;\\n        // We combine it with the data, because of our require this will have a clean\\n        // top 64 bits\\n        uint256 packedData = blockNumber | data;\\n        // Load the array length\\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\\n        // On the first push we don't try to load\\n        uint256 loadedBlockNumber = 0;\\n        if (length != 0) {\\n            (loadedBlockNumber, ) = _loadAndUnpack(storageData, length - 1);\\n        }\\n        // The index we push to, note - we use this pattern to not branch the assembly\\n        uint256 index = length;\\n        // If the caller is changing data in the same block we change the entry for this block\\n        // instead of adding a new one. This ensures each block numb is unique in the array.\\n        if (loadedBlockNumber == block.number) {\\n            index = length - 1;\\n        }\\n        // We use assembly to write our data to the index\\n        assembly {\\n            // Stores packed data in the equivalent of storageData[length]\\n            sstore(\\n                add(\\n                    // The start of the data slots\\n                    add(storageData.slot, 1),\\n                    // index where we store\\n                    index\\n                ),\\n                packedData\\n            )\\n        }\\n        // Reset the boundaries if they changed\\n        if (loadedBlockNumber != block.number) {\\n            _setBounds(storageData, minIndex, length + 1);\\n        }\\n    }\\n\\n    /// @notice Loads the most recent timestamp of delegation power\\n    /// @param wrapper The memory struct which we want to search for historical data\\n    /// @param who The user who's balance we want to load\\n    /// @return the top slot of the array\\n    function loadTop(\\n        HistoricalBalances memory wrapper,\\n        address who\\n    ) internal view returns (uint256) {\\n        // Load the storage pointer\\n        uint256[] storage userData = _getMapping(wrapper.cachedPointer)[who];\\n        // Load the length\\n        (, uint256 length) = _loadBounds(userData);\\n        // If it's zero no data has ever been pushed so we return zero\\n        if (length == 0) {\\n            return 0;\\n        }\\n        // Load the current top\\n        (, uint256 storedData) = _loadAndUnpack(userData, length - 1);\\n        // and return it\\n        return (storedData);\\n    }\\n\\n    /// @notice Finds the data stored with the highest block number which is less than or equal to a provided\\n    ///         blocknumber.\\n    /// @param wrapper The memory struct which we want to search for historical data\\n    /// @param who The address which indexes the array to be searched\\n    /// @param blocknumber The blocknumber we want to load the historical data of\\n    /// @return The loaded unpacked data at this point in time.\\n    function find(\\n        HistoricalBalances memory wrapper,\\n        address who,\\n        uint256 blocknumber\\n    ) internal view returns (uint256) {\\n        // Get the storage this is referencing\\n        mapping(address => uint256[]) storage storageMapping = _getMapping(\\n            wrapper.cachedPointer\\n        );\\n        // Get the array we need to push to\\n        uint256[] storage storageData = storageMapping[who];\\n        // Pre load the bounds\\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\\n        // Search for the blocknumber\\n        (, uint256 loadedData) = _find(\\n            storageData,\\n            blocknumber,\\n            0,\\n            minIndex,\\n            length\\n        );\\n        // In this function we don't have to change the stored length data\\n        return (loadedData);\\n    }\\n\\n    /// @notice Finds the data stored with the highest blocknumber which is less than or equal to a provided block number\\n    ///         Opportunistically clears any data older than staleBlock which is possible to clear.\\n    /// @param wrapper The memory struct which points to the storage we want to search\\n    /// @param who The address which indexes the historical data we want to search\\n    /// @param blocknumber The blocknumber we want to load the historical state of\\n    /// @param staleBlock A block number which we can [but are not obligated to] delete history older than\\n    /// @return The found data\\n    function findAndClear(\\n        HistoricalBalances memory wrapper,\\n        address who,\\n        uint256 blocknumber,\\n        uint256 staleBlock\\n    ) internal returns (uint256) {\\n        // Get the storage this is referencing\\n        mapping(address => uint256[]) storage storageMapping = _getMapping(\\n            wrapper.cachedPointer\\n        );\\n        // Get the array we need to push to\\n        uint256[] storage storageData = storageMapping[who];\\n        // Pre load the bounds\\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\\n        // Search for the blocknumber\\n        (uint256 staleIndex, uint256 loadedData) = _find(\\n            storageData,\\n            blocknumber,\\n            staleBlock,\\n            minIndex,\\n            length\\n        );\\n        // We clear any data in the stale region\\n        // Note - Since find returns 0 if no stale data is found and we use > instead of >=\\n        //        this won't trigger if no stale data is found. Plus it won't trigger on minIndex == staleIndex\\n        //        == maxIndex and clear the whole array.\\n        if (staleIndex > minIndex) {\\n            // Delete the outdated stored info\\n            _clear(minIndex, staleIndex, storageData);\\n            // Reset the array info with stale index as the new minIndex\\n            _setBounds(storageData, staleIndex, length);\\n        }\\n        return (loadedData);\\n    }\\n\\n    /// @notice Searches for the data stored at the largest blocknumber index less than a provided parameter.\\n    ///         Allows specification of a expiration stamp and returns the greatest examined index which is\\n    ///         found to be older than that stamp.\\n    /// @param data The stored data\\n    /// @param blocknumber the blocknumber we want to load the historical data for.\\n    /// @param staleBlock The oldest block that we care about the data stored for, all previous data can be deleted\\n    /// @param startingMinIndex The smallest filled index in the array\\n    /// @param length the length of the array\\n    /// @return Returns the largest stale data index seen or 0 for no seen stale data and the stored data\\n    function _find(\\n        uint256[] storage data,\\n        uint256 blocknumber,\\n        uint256 staleBlock,\\n        uint256 startingMinIndex,\\n        uint256 length\\n    ) private view returns (uint256, uint256) {\\n        // We explicitly revert on the reading of memory which is uninitialized\\n        require(length != 0, \\\"uninitialized\\\");\\n        // Do some correctness checks\\n        require(staleBlock <= blocknumber);\\n        require(startingMinIndex < length);\\n        // Load the bounds of our binary search\\n        uint256 maxIndex = length - 1;\\n        uint256 minIndex = startingMinIndex;\\n        uint256 staleIndex = 0;\\n\\n        // We run a binary search on the block number fields in the array between\\n        // the minIndex and maxIndex. If we find indexes with blocknumber < staleBlock\\n        // we set staleIndex to them and return that data for an optional clearing step\\n        // in the calling function.\\n        while (minIndex != maxIndex) {\\n            // We use the ceil instead of the floor because this guarantees that\\n            // we pick the highest blocknumber less than or equal the requested one\\n            uint256 mid = (minIndex + maxIndex + 1) / 2;\\n            // Load and unpack the data in the midpoint index\\n            (uint256 pastBlock, uint256 loadedData) = _loadAndUnpack(data, mid);\\n\\n            //  If we've found the exact block we are looking for\\n            if (pastBlock == blocknumber) {\\n                // Then we just return the data\\n                return (staleIndex, loadedData);\\n\\n                // Otherwise if the loaded block is smaller than the block number\\n            } else if (pastBlock < blocknumber) {\\n                // Then we first check if this is possibly a stale block\\n                if (pastBlock < staleBlock) {\\n                    // If it is we mark it for clearing\\n                    staleIndex = mid;\\n                }\\n                // We then repeat the search logic on the indices greater than the midpoint\\n                minIndex = mid;\\n\\n                // In this case the pastBlock > blocknumber\\n            } else {\\n                // We then repeat the search on the indices below the midpoint\\n                maxIndex = mid - 1;\\n            }\\n        }\\n\\n        // We load at the final index of the search\\n        (uint256 _pastBlock, uint256 _loadedData) = _loadAndUnpack(\\n            data,\\n            minIndex\\n        );\\n        // This will only be hit if a user has misconfigured the stale index and then\\n        // tried to load father into the past than has been preserved\\n        require(_pastBlock <= blocknumber, \\\"Search Failure\\\");\\n        return (staleIndex, _loadedData);\\n    }\\n\\n    /// @notice Clears storage between two bounds in array\\n    /// @param oldMin The first index to set to zero\\n    /// @param newMin The new minimum filled index, ie clears to index < newMin\\n    /// @param data The storage array pointer\\n    function _clear(\\n        uint256 oldMin,\\n        uint256 newMin,\\n        uint256[] storage data\\n    ) private {\\n        // Correctness checks on this call\\n        require(oldMin <= newMin);\\n        // This function is private and trusted and should be only called by functions which ensure\\n        // that oldMin < newMin < length\\n        assembly {\\n            // The layout of arrays in solidity is [length][data]....[data] so this pointer is the\\n            // slot to write to data\\n            let dataLocation := add(data.slot, 1)\\n            // Loop through each index which is below new min and clear the storage\\n            // Note - Uses strict min so if given an input like oldMin = 5 newMin = 5 will be a no op\\n            for {\\n                let i := oldMin\\n            } lt(i, newMin) {\\n                i := add(i, 1)\\n            } {\\n                // store at the starting data pointer + i 256 bits of zero\\n                sstore(add(dataLocation, i), 0)\\n            }\\n        }\\n    }\\n\\n    /// @notice Loads and unpacks the block number index and stored data from a data array\\n    /// @param data the storage array\\n    /// @param i the index to load and unpack\\n    /// @return (block number, stored data)\\n    function _loadAndUnpack(\\n        uint256[] storage data,\\n        uint256 i\\n    ) private view returns (uint256, uint256) {\\n        // This function is trusted and should only be called after checking data lengths\\n        // we use assembly for the sload to avoid reloading length.\\n        uint256 loaded;\\n        assembly {\\n            loaded := sload(add(add(data.slot, 1), i))\\n        }\\n        // Unpack the packed 64 bit block number and 192 bit data field\\n        return (\\n            loaded >> 192,\\n            loaded &\\n                0x0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff\\n        );\\n    }\\n\\n    /// @notice This function sets our non standard bounds data field where a normal array\\n    ///         would have length\\n    /// @param data the pointer to the storage array\\n    /// @param minIndex The minimum non stale index\\n    /// @param length The length of the storage array\\n    function _setBounds(\\n        uint256[] storage data,\\n        uint256 minIndex,\\n        uint256 length\\n    ) private {\\n        // Correctness check\\n        require(minIndex < length);\\n\\n        assembly {\\n            // Ensure data cleanliness\\n            let clearedLength := and(\\n                length,\\n                0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff\\n            )\\n            // We move the min index into the top 128 bits by shifting it left by 128 bits\\n            let minInd := shl(128, minIndex)\\n            // We pack the data using binary or\\n            let packed := or(minInd, clearedLength)\\n            // We store in the packed data in the length field of this storage array\\n            sstore(data.slot, packed)\\n        }\\n    }\\n\\n    /// @notice This function loads and unpacks our packed min index and length for our custom storage array\\n    /// @param data The pointer to the storage location\\n    /// @return minInd the first filled index in the array\\n    /// @return length the length of the array\\n    function _loadBounds(\\n        uint256[] storage data\\n    ) private view returns (uint256 minInd, uint256 length) {\\n        // Use assembly to manually load the length storage field\\n        uint256 packedData;\\n        assembly {\\n            packedData := sload(data.slot)\\n        }\\n        // We use a shift right to clear out the low order bits of the data field\\n        minInd = packedData >> 128;\\n        // We use a binary and to extract only the bottom 128 bits\\n        length =\\n            packedData &\\n            0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\\n    }\\n}\\n\",\"keccak256\":\"0x3714e8789c8fc88587e4951114cc0fa77a58f5781fef29f13c05d12f811d90a1\",\"license\":\"Apache-2.0\"},\"contracts/libraries/Storage.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\n// This library allows for secure storage pointers across proxy implementations\\n// It will return storage pointers based on a hashed name and type string.\\nlibrary Storage {\\n    // This library follows a pattern which if solidity had higher level\\n    // type or macro support would condense quite a bit.\\n\\n    // Each basic type which does not support storage locations is encoded as\\n    // a struct of the same name capitalized and has functions 'load' and 'set'\\n    // which load the data and set the data respectively.\\n\\n    // All types will have a function of the form 'typename'Ptr('name') -> storage ptr\\n    // which will return a storage version of the type with slot which is the hash of\\n    // the variable name and type string. This pointer allows easy state management between\\n    // upgrades and overrides the default solidity storage slot system.\\n\\n    /// @dev The address type container\\n    struct Address {\\n        address data;\\n    }\\n\\n    /// @notice A function which turns a variable name for a storage address into a storage\\n    ///         pointer for its container.\\n    /// @param name the variable name\\n    /// @return data the storage pointer\\n    function addressPtr(\\n        string memory name\\n    ) internal pure returns (Address storage data) {\\n        bytes32 typehash = keccak256(\\\"address\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n\\n    /// @notice A function to load an address from the container struct\\n    /// @param input the storage pointer for the container\\n    /// @return the loaded address\\n    function load(Address storage input) internal view returns (address) {\\n        return input.data;\\n    }\\n\\n    /// @notice A function to set the internal field of an address container\\n    /// @param input the storage pointer to the container\\n    /// @param to the address to set the container to\\n    function set(Address storage input, address to) internal {\\n        input.data = to;\\n    }\\n\\n    /// @dev The uint256 type container\\n    struct Uint256 {\\n        uint256 data;\\n    }\\n\\n    /// @notice A function which turns a variable name for a storage uint256 into a storage\\n    ///         pointer for its container.\\n    /// @param name the variable name\\n    /// @return data the storage pointer\\n    function uint256Ptr(\\n        string memory name\\n    ) internal pure returns (Uint256 storage data) {\\n        bytes32 typehash = keccak256(\\\"uint256\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n\\n    /// @notice A function to load an uint256 from the container struct\\n    /// @param input the storage pointer for the container\\n    /// @return the loaded uint256\\n    function load(Uint256 storage input) internal view returns (uint256) {\\n        return input.data;\\n    }\\n\\n    /// @notice A function to set the internal field of a unit256 container\\n    /// @param input the storage pointer to the container\\n    /// @param to the address to set the container to\\n    function set(Uint256 storage input, uint256 to) internal {\\n        input.data = to;\\n    }\\n\\n    /// @notice Returns the storage pointer for a named mapping of address to uint256\\n    /// @param name the variable name for the pointer\\n    /// @return data the mapping pointer\\n    function mappingAddressToUnit256Ptr(\\n        string memory name\\n    ) internal pure returns (mapping(address => uint256) storage data) {\\n        bytes32 typehash = keccak256(\\\"mapping(address => uint256)\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n\\n    /// @notice Returns the storage pointer for a named mapping of address to uint256[]\\n    /// @param name the variable name for the pointer\\n    /// @return data the mapping pointer\\n    function mappingAddressToUnit256ArrayPtr(\\n        string memory name\\n    ) internal pure returns (mapping(address => uint256[]) storage data) {\\n        bytes32 typehash = keccak256(\\\"mapping(address => uint256[])\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n\\n    /// @notice Returns the storage pointer for a named mapping of address to int24[]\\n    /// @param name the variable name for the pointer\\n    /// @return data the mapping pointer\\n    function mappingAddressToInt256ArrayPtr(\\n        string memory name\\n    ) internal pure returns (mapping(address => int256[]) storage data) {\\n        bytes32 typehash = keccak256(\\\"mapping(address => int256[])\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n\\n    /// @notice Allows external users to calculate the slot given by this lib\\n    /// @param typeString the string which encodes the type\\n    /// @param name the variable name\\n    /// @return the slot assigned by this lib\\n    function getPtr(\\n        string memory typeString,\\n        string memory name\\n    ) external pure returns (uint256) {\\n        bytes32 typehash = keccak256(abi.encodePacked(typeString));\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        return (uint256)(offset);\\n    }\\n\\n    // A struct which represents 1 packed storage location with a compressed\\n    // address and uint96 pair\\n    struct AddressUint {\\n        address who;\\n        uint96 amount;\\n    }\\n\\n    /// @notice Returns the storage pointer for a named mapping of address to uint256[]\\n    /// @param name the variable name for the pointer\\n    /// @return data the mapping pointer\\n    function mappingAddressToPackedAddressUint(\\n        string memory name\\n    ) internal pure returns (mapping(address => AddressUint) storage data) {\\n        bytes32 typehash = keccak256(\\\"mapping(address => AddressUint)\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x56a08f5d1eeccee2285785de2e3c0b15c0e5e41a86c573508912a835f568ceda\",\"license\":\"Apache-2.0\"},\"contracts/libraries/VestingVaultStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\n// Copy of `Storage` with modified scope to match the VestingVault requirements\\n// This library allows for secure storage pointers across proxy implementations\\n// It will return storage pointers based on a hashed name and type string.\\nlibrary VestingVaultStorage {\\n    // This library follows a pattern which if solidity had higher level\\n    // type or macro support would condense quite a bit.\\n\\n    // Each basic type which does not support storage locations is encoded as\\n    // a struct of the same name capitalized and has functions 'load' and 'set'\\n    // which load the data and set the data respectively.\\n\\n    // All types will have a function of the form 'typename'Ptr('name') -> storage ptr\\n    // which will return a storage version of the type with slot which is the hash of\\n    // the variable name and type string. This pointer allows easy state management between\\n    // upgrades and overrides the default solidity storage slot system.\\n\\n    // A struct which represents 1 packed storage location (Grant)\\n    struct Grant {\\n        uint128 allocation;\\n        uint128 withdrawn;\\n        uint128 created;\\n        uint128 expiration;\\n        uint128 cliff;\\n        uint128 latestVotingPower;\\n        address delegatee;\\n        uint256[2] range;\\n    }\\n\\n    /// @notice Returns the storage pointer for a named mapping of address to uint256[]\\n    /// @param name the variable name for the pointer\\n    /// @return data the mapping pointer\\n    function mappingAddressToGrantPtr(\\n        string memory name\\n    ) internal pure returns (mapping(address => Grant) storage data) {\\n        bytes32 typehash = keccak256(\\\"mapping(address => Grant)\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x07549833c084ef55837be46721211c991b69ab73d11be713325dd298c32d3991\",\"license\":\"Apache-2.0\"},\"contracts/vaults/FriendlyVault.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../libraries/History.sol\\\";\\nimport \\\"../libraries/VestingVaultStorage.sol\\\";\\nimport \\\"../libraries/Storage.sol\\\";\\nimport \\\"../interfaces/IVotingVault.sol\\\";\\nimport \\\"@aave/core-v3/contracts/mocks/tokens/MintableERC20.sol\\\";\\n\\ncontract FriendlyVault is IVotingVault {\\n    // extraData encodes a uint128 of votes to give to the user via abi.encode\\n    function queryVotePower(\\n        address user,\\n        uint256 blockNumber,\\n        bytes calldata extraData\\n    ) external override returns (uint256) {\\n        uint128 votes = abi.decode(extraData, (uint128));\\n        return uint256(votes);\\n    }\\n}\\n\",\"keccak256\":\"0x040da076ef5a470d735165f91998a26db8da8e1c2977f7c13fc7787f565668b9\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610172806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063e91f323514610030575b600080fd5b61004361003e366004610077565b610055565b60405190815260200160405180910390f35b6000806100648385018561010c565b6001600160801b03169695505050505050565b6000806000806060858703121561008d57600080fd5b84356001600160a01b03811681146100a457600080fd5b935060208501359250604085013567ffffffffffffffff808211156100c857600080fd5b818701915087601f8301126100dc57600080fd5b8135818111156100eb57600080fd5b8860208285010111156100fd57600080fd5b95989497505060200194505050565b60006020828403121561011e57600080fd5b81356001600160801b038116811461013557600080fd5b939250505056fea26469706673582212200747302d59615f04ac0f1a9666d3e36c833fa7a8908dff40375a87fccb50aabc64736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063e91f323514610030575b600080fd5b61004361003e366004610077565b610055565b60405190815260200160405180910390f35b6000806100648385018561010c565b6001600160801b03169695505050505050565b6000806000806060858703121561008d57600080fd5b84356001600160a01b03811681146100a457600080fd5b935060208501359250604085013567ffffffffffffffff808211156100c857600080fd5b818701915087601f8301126100dc57600080fd5b8135818111156100eb57600080fd5b8860208285010111156100fd57600080fd5b95989497505060200194505050565b60006020828403121561011e57600080fd5b81356001600160801b038116811461013557600080fd5b939250505056fea26469706673582212200747302d59615f04ac0f1a9666d3e36c833fa7a8908dff40375a87fccb50aabc64736f6c634300080a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "queryVotePower(address,uint256,bytes)": {
        "params": {
          "blockNumber": "the block number we want the user's voting power at",
          "extraData": "Abi encoded optional extra data used by some vaults, such as merkle proofs",
          "user": "The address we want to load the voting power of"
        },
        "returns": {
          "_0": "the number of votes"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "queryVotePower(address,uint256,bytes)": {
        "notice": "Attempts to load the voting power of a user"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}